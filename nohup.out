
  You can now view your Streamlit app in your browser.

  Network URL: http://192.168.181.71:8501
  External URL: http://143.178.193.216:8501

2024-01-14 20:03:28.002 Session with id 7b3646ec-589b-4962-b370-6090679afc82 is already connected! Connecting to a new session.
2024-01-15 06:57:34.616 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 383, in <module>
    response = get_streaming_response(st.session_state.messages)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 67, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value

  You can now view your Streamlit app in your browser.

  Network URL: http://192.168.181.71:8501
  External URL: http://143.178.193.216:8501

2024-01-15 18:06:27.968 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 385, in <module>
    placeholder = st.empy()
                  ^^^^^^^
AttributeError: module 'streamlit' has no attribute 'empy'
2024-01-15 18:07:18.343 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 391, in <module>
    append_message(response)
  File "/root/cs50p/project/main.py", line 195, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 215, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 18:08:45.259 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 396, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 151, in message_func
    st.write(text)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/write.py", line 263, in write
    self.dg.help(arg)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/doc_string.py", line 122, in help
    _marshall(doc_string_proto, obj)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/doc_string.py", line 136, in _marshall
    var_name = _get_variable_name()
               ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/doc_string.py", line 247, in _get_variable_name
    return _get_variable_name_from_code_str(code)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/doc_string.py", line 251, in _get_variable_name_from_code_str
    tree = ast.parse(code)
           ^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/ast.py", line 50, in parse
    return compile(source, filename, mode, flags,
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<unknown>", line 1
    message_func(
                ^
SyntaxError: '(' was never closed
2024-01-15 18:10:09.135 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 368, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 45, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 195, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 215, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 18:13:16.876 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 368, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 45, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 195, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 215, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 18:13:51.073 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 368, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 45, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 195, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 215, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 18:15:41.837 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 384, in <module>
    append_message(response)
  File "/root/cs50p/project/main.py", line 195, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 215, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 18:16:50.399 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 390, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 151, in message_func
    st.write(text)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/write.py", line 263, in write
    self.dg.help(arg)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/doc_string.py", line 122, in help
    _marshall(doc_string_proto, obj)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/doc_string.py", line 136, in _marshall
    var_name = _get_variable_name()
               ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/doc_string.py", line 247, in _get_variable_name
    return _get_variable_name_from_code_str(code)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/doc_string.py", line 251, in _get_variable_name_from_code_str
    tree = ast.parse(code)
           ^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/ast.py", line 50, in parse
    return compile(source, filename, mode, flags,
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<unknown>", line 1
    message_func(
                ^
SyntaxError: '(' was never closed
2024-01-15 18:22:33.035 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 367, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 45, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 194, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 214, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 19:13:49.729 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 368, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 45, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 195, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 215, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 19:16:52.079 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 46, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 196, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 216, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 19:17:48.643 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 46, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 196, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 216, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 19:18:07.814 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 46, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 196, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 216, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 19:19:22.779 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 370, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 46, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 196, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 217, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 19:21:28.280 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 379, in <module>
    chat_history = load_chat_history()
                   ^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 235, in load_chat_history
    record = json.loads(line)
             ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/decoder.py", line 340, in decode
    raise JSONDecodeError("Extra data", s, end)
json.decoder.JSONDecodeError: Extra data: line 1 column 2437 (char 2436)
2024-01-15 19:22:20.855 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 379, in <module>
    chat_history = load_chat_history()
                   ^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 235, in load_chat_history
    record = json.loads(line)
             ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/decoder.py", line 340, in decode
    raise JSONDecodeError("Extra data", s, end)
json.decoder.JSONDecodeError: Extra data: line 1 column 2437 (char 2436)
2024-01-15 19:22:23.560 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 379, in <module>
    chat_history = load_chat_history()
                   ^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 235, in load_chat_history
    record = json.loads(line)
             ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/decoder.py", line 340, in decode
    raise JSONDecodeError("Extra data", s, end)
json.decoder.JSONDecodeError: Extra data: line 1 column 2437 (char 2436)
2024-01-15 19:22:25.530 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 379, in <module>
    chat_history = load_chat_history()
                   ^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 235, in load_chat_history
    record = json.loads(line)
             ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/decoder.py", line 340, in decode
    raise JSONDecodeError("Extra data", s, end)
json.decoder.JSONDecodeError: Extra data: line 1 column 2437 (char 2436)
2024-01-15 19:22:25.731 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 379, in <module>
    chat_history = load_chat_history()
                   ^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 235, in load_chat_history
    record = json.loads(line)
             ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/decoder.py", line 340, in decode
    raise JSONDecodeError("Extra data", s, end)
json.decoder.JSONDecodeError: Extra data: line 1 column 2437 (char 2436)
2024-01-15 20:13:28.928 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 360, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 45, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 187, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 207, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 20:14:47.015 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 359, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 45, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 186, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 206, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-15 20:16:04.597 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 360, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 45, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 186, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 207, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type generator is not JSON serializable
2024-01-16 07:41:15.565 Session with id 79bc04a3-4651-47a7-b52b-d97cace81c2c is already connected! Connecting to a new session.
2024-01-16 12:59:27.363 Session with id 169a653e-c043-4615-942a-50acd3b445cc is already connected! Connecting to a new session.
Exception ignored in: <async_generator object stream_generate at 0x7f0a40426650>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
Exception ignored in: <async_generator object stream_generate at 0x7f0a2b3017d0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
Exception ignored in: <async_generator object stream_generate at 0x7f0a401d2820>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
2024-01-18 08:53:26.834 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 371, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 122, in message_func
    hstr = chat[chatID]
           ~~~~^^^^^^^^
KeyError: '7261f904-fefd-455f-9239-1639fdc75c11'
2024-01-18 09:06:07.547 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 356, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 46, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 175, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 164, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 68, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
Exception ignored in: <async_generator object stream_generate at 0x7f0a401d2bc0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
2024-01-18 09:08:53.667 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 356, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 46, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 175, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 164, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 68, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-18 09:12:07.921 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 356, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 46, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 183, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 203, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type coroutine is not JSON serializable
2024-01-18 09:12:39.436 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 356, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 46, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 183, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 203, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type coroutine is not JSON serializable
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/cachetools/__init__.py:90: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  del self.__data[key]
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-18 09:16:23.446 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 357, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 46, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 184, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 204, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type coroutine is not JSON serializable
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/cachetools/__init__.py:90: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  del self.__data[key]
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-18 09:22:53.209 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 356, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 46, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 175, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 164, in get_subject_message
    subject = asyncio.run(get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/runners.py", line 190, in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/runners.py", line 89, in run
    raise ValueError("a coroutine was expected, got {!r}".format(coro))
ValueError: a coroutine was expected, got 'Code Error: Coroutine Object Not JSON Serializable\n\n'
Exception ignored in: <async_generator object stream_generate at 0x7f0a2b301090>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
2024-01-18 13:04:47.875 Session with id bdb8f17a-13fc-478f-b57b-8f8b3f74808e is already connected! Connecting to a new session.
2024-01-18 13:38:45.506 Session with id cbe651d8-f776-45b8-a427-e40d1818d5ba is already connected! Connecting to a new session.
2024-01-18 13:39:33.009 Session with id 7092800a-377a-40d7-a005-f05c086c6a08 is already connected! Connecting to a new session.
2024-01-18 15:23:19.846 Session with id 86fd7351-66a5-40cb-98b8-83b154c86909 is already connected! Connecting to a new session.
2024-01-18 16:48:23.670 Session with id fe9897c0-5d98-43d4-affa-fa2f02a71ca5 is already connected! Connecting to a new session.
2024-01-19 05:22:49.354 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 389, in <module>
    for item in response:
  File "/root/cs50p/project/gpt4free/g4f/Provider/base_provider.py", line 149, in create_completion
    yield loop.run_until_complete(gen.__anext__())
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/Bing.py", line 503, in stream_generate
    raise Exception(f"{result['value']}: {result['message']}")
Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.
2024-01-19 05:23:30.558 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 389, in <module>
    for item in response:
  File "/root/cs50p/project/gpt4free/g4f/Provider/base_provider.py", line 149, in create_completion
    yield loop.run_until_complete(gen.__anext__())
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/Bing.py", line 503, in stream_generate
    raise Exception(f"{result['value']}: {result['message']}")
Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.
2024-01-19 06:26:41.953 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 389, in <module>
    for item in response:
  File "/root/cs50p/project/gpt4free/g4f/Provider/base_provider.py", line 149, in create_completion
    yield loop.run_until_complete(gen.__anext__())
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/Bing.py", line 503, in stream_generate
    raise Exception(f"{result['value']}: {result['message']}")
Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.
2024-01-19 06:53:17.083 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 378, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 129, in message_func
    hstr = chat[chatID]
           ~~~~^^^^^^^^
KeyError: '09c76d16-e918-41b8-8c7c-0c199f7a4f98'
2024-01-19 06:54:34.810 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 378, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 129, in message_func
    hstr = chat[chatID]
           ~~~~^^^^^^^^
KeyError: '90ce2597-a0fc-4560-a4c9-c60d9903ea3f'
2024-01-19 06:58:04.705 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 379, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 129, in message_func
    st.write(hstr)
             ^^^^
UnboundLocalError: cannot access local variable 'hstr' where it is not associated with a value
2024-01-19 09:02:43.600 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 380, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 130, in message_func
    st.write(hstr)
             ^^^^
UnboundLocalError: cannot access local variable 'hstr' where it is not associated with a value
2024-01-19 10:28:34.140 Session with id 289f8fa2-9c13-4c9f-a0fe-4d4e2a9b29ee is already connected! Connecting to a new session.
2024-01-19 11:07:20.946 Session with id 29adba1a-e3c1-40c1-93c4-746a1648d43b is already connected! Connecting to a new session.
2024-01-19 11:45:30.004 Session with id 457aed35-4d94-42c5-8bf8-df8f54681e8e is already connected! Connecting to a new session.
2024-01-19 12:59:37.029 Session with id 9c24644a-022e-40f2-8a6b-265e7f22e767 is already connected! Connecting to a new session.
2024-01-19 13:01:47.717 Session with id f6877064-0cc5-4709-a563-2791b68fc0df is already connected! Connecting to a new session.
2024-01-19 13:02:41.785 Session with id d4d57f50-6083-4f12-8c5c-59fe0fd051ae is already connected! Connecting to a new session.
2024-01-19 13:17:26.111 Session with id 6af09c3e-2910-4707-a297-7a5672f0bbab is already connected! Connecting to a new session.
2024-01-19 16:01:47.277 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 379, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 119, in message_func
    if message["counter"] > 1:
       ~~~~~~~^^^^^^^^^^^
KeyError: 'counter'
2024-01-19 16:03:50.655 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 381, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 119, in message_func
    if message["counter"] > 1:
       ^^^^^^^^^^^^^^^^^^^^^^
TypeError: '>' not supported between instances of 'NoneType' and 'int'
2024-01-19 16:22:08.651 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 380, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 127, in message_func
    hstr = chat[chatID]
           ~~~~^^^^^^^^
KeyError: 'c206de50-d40a-4a4f-b2e4-a3af1fba81e3'
Exception ignored in: <async_generator object stream_generate at 0x7f0a40426650>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
Exception ignored in: <async_generator object stream_generate at 0x7f0a40f17870>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
2024-01-19 17:55:55.902 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 378, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 272, in display_chat_history_sidebar
    subject = msg[1]['subject']
              ~~~^^^
IndexError: list index out of range
2024-01-19 17:57:11.649 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 378, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 272, in display_chat_history_sidebar
    subject = msg[1]['subject']
              ~~~^^^
IndexError: list index out of range
2024-01-19 18:25:57.792 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 380, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 272, in display_chat_history_sidebar
    subject = msg[1]["subject"]
              ~~~^^^
IndexError: list index out of range
Exception ignored in: <async_generator object stream_generate at 0x7f0a40f17870>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
2024-01-19 20:02:13.674 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 269, in display_chat_history_sidebar
    subject = msg[1]['subject']
              ~~~^^^
IndexError: list index out of range
2024-01-19 20:02:51.926 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 276, in display_chat_history_sidebar
    grouped_by_date[date].append((subject, chatID))
                                  ^^^^^^^
UnboundLocalError: cannot access local variable 'subject' where it is not associated with a value
2024-01-19 20:08:33.056 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 378, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 269, in display_chat_history_sidebar
    st.write(msg[1])
             ~~~^^^
IndexError: list index out of range
2024-01-19 20:08:33.499 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 378, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 269, in display_chat_history_sidebar
    st.write(msg[1])
             ~~~^^^
IndexError: list index out of range
2024-01-20 09:37:57.436 Session with id 2df244a7-25bd-4283-b466-08377900a602 is already connected! Connecting to a new session.
2024-01-20 09:43:15.508 Session with id 5d48c703-85ad-4db7-ac64-a1d9d5c58edb is already connected! Connecting to a new session.
2024-01-20 09:46:05.657 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 47, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 180, in append_message
    subject = asyncio.run(get_subject_message(content))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 169, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 69, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 09:47:25.032 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 47, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 180, in append_message
    subject = asyncio.run(get_subject_message(content))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 169, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 69, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
Task was destroyed but it is pending!
task: <Task cancelling name='Task-108394' coro=<AsyncCurl._force_timeout() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/curl_cffi/aio.py:118> wait_for=<Future cancelled>>
Task was destroyed but it is pending!
task: <Task cancelling name='Task-108579' coro=<AsyncCurl._force_timeout() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/curl_cffi/aio.py:118> wait_for=<Future cancelled>>
2024-01-20 10:11:18.547 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 367, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 181, in append_message
    subject = asyncio.run(get_subject_message(content))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 170, in get_subject_message
    subject = await get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo_0613)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object str can't be used in 'await' expression
2024-01-20 10:11:48.758 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 367, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 181, in append_message
    subject = asyncio.run(get_subject_message(content))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 170, in get_subject_message
    subject = await get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo_0613, stream=True)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object generator can't be used in 'await' expression
2024-01-20 10:12:45.244 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 367, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 181, in append_message
    subject = asyncio.run(get_subject_message(content))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 170, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo_0613)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:13:07.790 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 367, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 192, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 212, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type coroutine is not JSON serializable
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'get_streaming_response' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:48: RuntimeWarning: coroutine 'append_message' was never awaited
  append_message(prompt, role='user')
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:48: RuntimeWarning: coroutine 'append_message' was never awaited
  append_message(prompt, role='user')
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:48: RuntimeWarning: coroutine 'append_message' was never awaited
  append_message(prompt, role='user')
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-20 10:29:10.955 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 182, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 171, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.claude_instant_v1)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:30:17.843 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 182, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 171, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.claude_v1)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:30:27.544 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 182, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 171, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.claude_v2)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:30:41.199 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 182, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 171, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.code_davinci_002)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:30:54.170 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 182, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 171, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.command_light_nightly)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:31:14.126 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 182, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 171, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.falcon_7b)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:31:25.251 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 182, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 171, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.flan_t5_xxl)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:31:48.911 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 182, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 171, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.llama13b_v2_chat)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:32:07.302 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 182, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 171, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.oasst_sft_1_pythia_12b)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:32:27.797 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 368, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 181, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 170, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.text_davinci_003)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:32:38.725 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 368, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 181, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 170, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt4)
                                                                  ^^^^^^^^^^^^^^^
AttributeError: module 'gpt4free.g4f.models' has no attribute 'gpt4'
2024-01-20 10:33:05.794 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 368, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 181, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 170, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.OnlineGpt.supports_gpt_35_turbo)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 70, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-20 10:33:55.823 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 368, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 48, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 181, in append_message
    subject = get_subject_message(content)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 169, in get_subject_message
    with st.sidebar.spinner("Getting subject"):
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/delta_generator.py", line 352, in wrapper
    raise StreamlitAPIException(message)
streamlit.errors.StreamlitAPIException: Method `spinner()` does not exist for `st.sidebar`. Did you mean `st.spinner()`?
2024-01-20 10:57:25.521 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 49, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 190, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 210, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type coroutine is not JSON serializable
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-20 10:57:50.900 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 49, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 190, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 210, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type coroutine is not JSON serializable
2024-01-20 10:58:44.771 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 49, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 190, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 210, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type coroutine is not JSON serializable
2024-01-20 10:59:42.377 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 49, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 190, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 210, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type coroutine is not JSON serializable
2024-01-20 11:04:14.333 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 49, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 190, in append_message
    save_or_delete_message_in_jsonl(message)
  File "/root/cs50p/project/main.py", line 210, in save_or_delete_message_in_jsonl
    json_record = json.dumps(message)
                  ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type coroutine is not JSON serializable
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-21 17:37:32.841 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 9, in <module>
    st.set_page_config(page_title="GPT4LL", page_icon="️‍‍☠️", layout="centered", initial_sidebar_state="collapsed", menu_items=None)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/commands/page_config.py", line 227, in set_page_config
    ctx.enqueue(msg)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_run_context.py", line 100, in enqueue
    raise StreamlitAPIException(
streamlit.errors.StreamlitAPIException: `set_page_config()` can only be called once per app page, and must be called as the first Streamlit command in your script.

For more information refer to the [docs](https://docs.streamlit.io/library/api-reference/utilities/st.set_page_config).
2024-01-21 17:41:52.884 Uncaught app exception
Traceback (most recent call last):
  File "/root/cs50p/project/main.py", line 63, in get_streaming_response
    response = g4f.ChatCompletion.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/__init__.py", line 79, in create
    return result if stream else ''.join(result)
                                 ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 60, in create_completion
    self.raise_exceptions()
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 88, in raise_exceptions
    raise RetryProviderError("RetryProvider failed:\n" + "\n".join([
gpt4free.g4f.errors.RetryProviderError: RetryProvider failed:
Liaobots: ClientResponseError: 401, message='Unauthorized', url=URL('https://liaobots.work/api/user')
Bing: Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 387, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 174, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_4)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 72, in get_streaming_response
    response = get_streaming_response(messages=messages,model=g4f.models.gpt_4_0613)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 73, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
Task was destroyed but it is pending!
task: <Task cancelling name='Task-141273' coro=<AsyncCurl._force_timeout() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/curl_cffi/aio.py:118> wait_for=<Future cancelled>>
2024-01-21 17:46:40.144 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    conn.close()
    ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/base_connection.py", line 84, in __getattribute__
    raise e
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/base_connection.py", line 78, in __getattribute__
    return object.__getattribute__(self, name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'SQLConnection' object has no attribute 'close'
2024-01-21 17:50:38.029 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 389, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 234, in save_or_delete_message_in_sql
    values = (message["messageID"], message["chatID"], message["role"], message["content"], message["subjectID"], message["date"])
                                                                                            ~~~~~~~^^^^^^^^^^^^^
KeyError: 'subjectID'
/root/cs50p/project/main.py:235: RemovedIn20Warning: Deprecated API features detected! These feature(s) are not compatible with SQLAlchemy 2.0. To prevent incompatible upgrades prior to updating applications, ensure requirements files are pinned to "sqlalchemy<2.0". Set environment variable SQLALCHEMY_WARN_20=1 to show all deprecation warnings.  Set environment variable SQLALCHEMY_SILENCE_UBER_WARNING=1 to silence this message. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
  s.execute(sql, values).commit()
2024-01-21 17:59:14.474 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: table messages has no column named subjectID

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 389, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 235, in save_or_delete_message_in_sql
    s.execute(sql, values).commit()
    ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table messages has no column named subjectID
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,subjectID,date)
                VALUES(?, ?, ?, ?, ?, ?);
                ]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-21 17:59:51.185 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 389, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 235, in save_or_delete_message_in_sql
    s.execute(sql, values).commit()
    ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date)
                VALUES(?, ?, ?, ?, ?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-21 18:00:39.714 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 391, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 236, in save_or_delete_message_in_sql
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date)
                VALUES(?, ?, ?, ?, ?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 12:51:44.163 Session with id 758eb433-2d59-4209-9e6c-3bb657840827 is already connected! Connecting to a new session.
2024-01-22 14:24:57.722 Session with id 363ee0a7-4ed1-4aba-824c-ffe8f69cdf08 is already connected! Connecting to a new session.
2024-01-22 17:39:26.426 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 392, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 237, in save_or_delete_message_in_sql
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date)
                VALUES(?, ?, ?, ?, ?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 17:40:49.656 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 392, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 237, in save_or_delete_message_in_sql
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date)
                VALUES(?, ?, ?, ?, ?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 17:43:05.120 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 393, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 238, in save_or_delete_message_in_sql
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date)
                VALUES(?, ?, ?, ?, ?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 17:46:53.107 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 390, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 235, in save_or_delete_message_in_sql
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.
[SQL: INSERT INTO messages(messageID,chatID,role,content,date) VALUES(?, ?, ?, ?, ?);]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 17:51:18.187 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1880, in _execute_context
    self.dialect.do_executemany(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 733, in do_executemany
    cursor.executemany(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 393, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 238, in save_or_delete_message_in_sql
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1880, in _execute_context
    self.dialect.do_executemany(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 733, in do_executemany
    cursor.executemany(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date)
                VALUES(?, ?, ?, ?, ?);
                ]
[parameters: ((), (), (), (), ())]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 17:52:19.447 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1880, in _execute_context
    self.dialect.do_executemany(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 733, in do_executemany
    cursor.executemany(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 394, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 239, in save_or_delete_message_in_sql
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1880, in _execute_context
    self.dialect.do_executemany(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 733, in do_executemany
    cursor.executemany(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 5, and there are 0 supplied.
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date)
                VALUES(?, ?, ?, ?, ?);
                ]
[parameters: ((), (), (), (), ())]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 17:54:19.815 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1880, in _execute_context
    self.dialect.do_executemany(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 733, in do_executemany
    cursor.executemany(statement, parameters)
sqlite3.OperationalError: 1 values for 5 columns

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 393, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 238, in save_or_delete_message_in_sql
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1880, in _execute_context
    self.dialect.do_executemany(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 733, in do_executemany
    cursor.executemany(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) 1 values for 5 columns
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date)
                VALUES(?);
                ]
[parameters: ((), (), (), (), ())]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-22 17:55:26.901 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1880, in _execute_context
    self.dialect.do_executemany(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 733, in do_executemany
    cursor.executemany(statement, parameters)
sqlite3.OperationalError: 1 values for 5 columns

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 393, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 238, in save_or_delete_message_in_sql
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1880, in _execute_context
    self.dialect.do_executemany(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 733, in do_executemany
    cursor.executemany(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) 1 values for 5 columns
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date)
                VALUES(?);
                ]
[parameters: ((), (), (), (), ())]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-22 18:02:20.579 Uncaught app exception
Traceback (most recent call last):
  File "/root/cs50p/project/main.py", line 63, in get_streaming_response
    response = g4f.ChatCompletion.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/__init__.py", line 79, in create
    return result if stream else ''.join(result)
                                 ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 60, in create_completion
    self.raise_exceptions()
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 88, in raise_exceptions
    raise RetryProviderError("RetryProvider failed:\n" + "\n".join([
gpt4free.g4f.errors.RetryProviderError: RetryProvider failed:
Bing: Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.
Liaobots: ClientResponseError: 401, message='Unauthorized', url=URL('https://liaobots.work/api/user')

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 393, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 174, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_4)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 72, in get_streaming_response
    response = get_streaming_response(messages=messages,model=g4f.models.gpt_4_0613)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 73, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-22 18:02:41.375 Uncaught app exception
Traceback (most recent call last):
  File "/root/cs50p/project/main.py", line 63, in get_streaming_response
    response = g4f.ChatCompletion.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/__init__.py", line 79, in create
    return result if stream else ''.join(result)
                                 ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 60, in create_completion
    self.raise_exceptions()
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 88, in raise_exceptions
    raise RetryProviderError("RetryProvider failed:\n" + "\n".join([
gpt4free.g4f.errors.RetryProviderError: RetryProvider failed:
Liaobots: ClientResponseError: 401, message='Unauthorized', url=URL('https://liaobots.work/api/user')
Bing: Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 393, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 174, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_4)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 72, in get_streaming_response
    response = get_streaming_response(messages=messages,model=g4f.models.gpt_4_0613)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 73, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-22 18:03:52.757 Uncaught app exception
Traceback (most recent call last):
  File "/root/cs50p/project/main.py", line 63, in get_streaming_response
    response = g4f.ChatCompletion.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/__init__.py", line 79, in create
    return result if stream else ''.join(result)
                                 ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 60, in create_completion
    self.raise_exceptions()
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 88, in raise_exceptions
    raise RetryProviderError("RetryProvider failed:\n" + "\n".join([
gpt4free.g4f.errors.RetryProviderError: RetryProvider failed:
Liaobots: ClientResponseError: 401, message='Unauthorized', url=URL('https://liaobots.work/api/user')
Bing: Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 393, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 174, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_4)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 72, in get_streaming_response
    response = get_streaming_response(messages=messages,model=g4f.models.gpt_4_0613)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 73, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-22 18:04:27.223 Uncaught app exception
Traceback (most recent call last):
  File "/root/cs50p/project/main.py", line 63, in get_streaming_response
    response = g4f.ChatCompletion.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/__init__.py", line 79, in create
    return result if stream else ''.join(result)
                                 ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 60, in create_completion
    self.raise_exceptions()
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 88, in raise_exceptions
    raise RetryProviderError("RetryProvider failed:\n" + "\n".join([
gpt4free.g4f.errors.RetryProviderError: RetryProvider failed:
Liaobots: ClientResponseError: 401, message='Unauthorized', url=URL('https://liaobots.work/api/user')
Bing: Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 393, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 174, in get_subject_message
    subject = get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_4)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 72, in get_streaming_response
    response = get_streaming_response(messages=messages,model=g4f.models.gpt_4_0613)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 73, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
Task was destroyed but it is pending!
task: <Task cancelling name='Task-172818' coro=<AsyncCurl._force_timeout() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/curl_cffi/aio.py:118> wait_for=<Future cancelled>>
2024-01-22 18:05:43.395 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    chat_history = load_chat_history()
                   ^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 256, in load_chat_history
    record = json.loads(line)
             ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/decoder.py", line 340, in decode
    raise JSONDecodeError("Extra data", s, end)
json.decoder.JSONDecodeError: Extra data: line 1 column 1085 (char 1084)
2024-01-22 18:06:14.283 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    chat_history = load_chat_history()
                   ^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 256, in load_chat_history
    record = json.loads(line)
             ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/decoder.py", line 340, in decode
    raise JSONDecodeError("Extra data", s, end)
json.decoder.JSONDecodeError: Extra data: line 1 column 1085 (char 1084)
2024-01-22 18:07:37.552 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    chat_history = load_chat_history()
                   ^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 256, in load_chat_history
    record = json.loads(line)
             ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/decoder.py", line 340, in decode
    raise JSONDecodeError("Extra data", s, end)
json.decoder.JSONDecodeError: Extra data: line 1 column 1513 (char 1512)
2024-01-22 18:10:30.291 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 391, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    append_message(prompt, subject ,role='user')
  File "/root/cs50p/project/main.py", line 193, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 237, in save_or_delete_message_in_sql
    s.execute(sql, values).commit()
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'CursorResult' object has no attribute 'commit'
2024-01-22 18:17:07.873 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: 1 values for 2 columns

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 183, in get_subject_message
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) 1 values for 2 columns
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?);
                ]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-22 18:17:48.615 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 183, in get_subject_message
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?,?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 18:18:41.125 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1880, in _execute_context
    self.dialect.do_executemany(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 733, in do_executemany
    cursor.executemany(statement, parameters)
sqlite3.OperationalError: 1 values for 2 columns

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 183, in get_subject_message
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1880, in _execute_context
    self.dialect.do_executemany(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 733, in do_executemany
    cursor.executemany(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) 1 values for 2 columns
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?);
                ]
[parameters: ((), ())]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-22 18:20:34.282 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: 1 values for 2 columns

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 183, in get_subject_message
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) 1 values for 2 columns
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?);
                ]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-22 18:21:54.578 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 183, in get_subject_message
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?,?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 18:25:34.271 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 183, in get_subject_message
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?,?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 19:23:33.368 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 183, in get_subject_message
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?,?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 19:26:43.377 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 183, in get_subject_message
    s.execute(sql, (chatID,subject))
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?,?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 20:54:26.553 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 403, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 183, in get_subject_message
    s.execute(sql, (chatID,subject))
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?,?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 20:55:33.490 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 404, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 184, in get_subject_message
    s.execute(sql, (chatID,subject))
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?,?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 20:57:08.395 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 404, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 184, in get_subject_message
    s.execute(sql, (chatID,subject))
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 2, and there are 0 supplied.
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?,?);
                ]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 21:01:40.669 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: You can only execute one statement at a time.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 453, in <module>
    save_or_delete_message_in_sql(None,chatID)
  File "/root/cs50p/project/main.py", line 237, in save_or_delete_message_in_sql
    s.execute(sql, values)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) You can only execute one statement at a time.
[SQL: DELETE FROM messages WHERE chatID = ?;DELETE FROM subject WHERE chatID = ?;]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 21:04:48.113 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: You can only execute one statement at a time.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 452, in <module>
    save_or_delete_message_in_sql(None,chatID)
  File "/root/cs50p/project/main.py", line 236, in save_or_delete_message_in_sql
    s.execute(sql, {"chatID":chatID_to_delete})
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) You can only execute one statement at a time.
[SQL: DELETE FROM messages WHERE chatID = ?;DELETE FROM subject WHERE chatID = ?;]
[parameters: ('92341529-edb9-46ff-a7e3-6df3c3a5e8fb', '92341529-edb9-46ff-a7e3-6df3c3a5e8fb')]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 21:05:37.226 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: You can only execute one statement at a time.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 452, in <module>
    save_or_delete_message_in_sql(None,chatID)
  File "/root/cs50p/project/main.py", line 236, in save_or_delete_message_in_sql
    s.execute(sql, {"chatID":chatID_to_delete})
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) You can only execute one statement at a time.
[SQL: DELETE FROM messages WHERE chatID = ?;DELETE FROM subject WHERE chatID = ?;]
[parameters: ('6250b6d4-9ba0-4e4d-8510-f35d3cb0ad54', '6250b6d4-9ba0-4e4d-8510-f35d3cb0ad54')]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-22 21:07:12.254 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: You can only execute one statement at a time.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 452, in <module>
    save_or_delete_message_in_sql(None,chatID)
  File "/root/cs50p/project/main.py", line 236, in save_or_delete_message_in_sql
    s.execute(sql, {"chatID":chatID_to_delete})
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) You can only execute one statement at a time.
[SQL: DELETE FROM messages WHERE chatID = ?;DELETE FROM subject WHERE chatID = ?;]
[parameters: ('55df9d0b-7ece-435f-a67e-c2b084a250d3', '55df9d0b-7ece-435f-a67e-c2b084a250d3')]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-23 07:33:25.778 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 468, in <module>
    for item in response:
  File "/root/cs50p/project/gpt4free/g4f/Provider/base_provider.py", line 149, in create_completion
    yield loop.run_until_complete(gen.__anext__())
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/Bing.py", line 503, in stream_generate
    raise Exception(f"{result['value']}: {result['message']}")
Exception: InternalError: ServiceClient failure for DeepLeo
2024-01-23 08:57:57.154 Session with id d0a2e642-9bba-4555-a627-0d140f5c0190 is already connected! Connecting to a new session.
2024-01-23 09:01:46.671 Session with id d441aa79-8aab-4e9b-b09b-b109c5d98297 is already connected! Connecting to a new session.
2024-01-23 09:04:54.557 Session with id 89ccb897-4b0f-4f31-bf05-561695ec662b is already connected! Connecting to a new session.
2024-01-23 17:57:12.023 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 437, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 178, in get_subject_message
    subject = str(get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo))
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 73, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Error connecting to the database: (sqlite3.OperationalError) no such column: date_add
[SQL: SELECT * FROM messages WHERE chatID = ? AND date_add < (SELECT date_add FROM messages WHERE messageID = ?);]
[parameters: ('3dd3f347-1aaa-4a9b-86a9-22e565eef912', '8d425221-d32f-4057-adf7-a44a479df3fa')]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
Failed to check g4f pypi version: Version not found
Error connecting to the database: (sqlite3.OperationalError) no such column: date_add
[SQL: SELECT * FROM messages WHERE chatID = ? AND date_add < (SELECT date_add FROM messages WHERE messageID = ?);]
[parameters: ('3dd3f347-1aaa-4a9b-86a9-22e565eef912', '1fa039e8-ee54-435e-ad1d-094d2de9079d')]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Error connecting to the database: 2024-01-23 18:18:48.096 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 388, in <module>
    chat_history = load_chat_history()
                   ^^^^^^^^^^^^^^^^^
NameError: name 'load_chat_history' is not defined
2024-01-23 18:19:11.390 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 388, in <module>
    chat_history = load_chat_history()
                   ^^^^^^^^^^^^^^^^^
NameError: name 'load_chat_history' is not defined
2024-01-23 18:19:48.337 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 389, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 283, in display_chat_history_sidebar
    subject = msg[0]['subject']
              ~~~~~~^^^^^^^^^^^
KeyError: 'subject'
2024-01-23 18:20:38.815 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 390, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 284, in display_chat_history_sidebar
    subject = msg[0]['subject']
              ~~~~~~^^^^^^^^^^^
KeyError: 'subject'
2024-01-23 18:21:03.906 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 389, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 283, in display_chat_history_sidebar
    subject = msg[0]['subject']
              ~~~~~~^^^^^^^^^^^
KeyError: 'subject'
2024-01-23 18:24:41.348 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 388, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 282, in display_chat_history_sidebar
    subject = msg[0]['subject']
              ~~~~~~^^^^^^^^^^^
KeyError: 'subject'
2024-01-23 18:25:39.635 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 371, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 260, in display_chat_history_sidebar
    if msg[0]["role"] == "system" and len(msg) == 1:
       ~~~~~~^^^^^^^^
TypeError: 'NoneType' object is not subscriptable
2024-01-23 18:25:56.438 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 371, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 260, in display_chat_history_sidebar
    if msg[0]["role"] == "system" and len(msg) == 1:
       ~~~~~~^^^^^^^^
TypeError: 'NoneType' object is not subscriptable
2024-01-23 18:26:16.232 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 371, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 260, in display_chat_history_sidebar
    if msg[0]["role"] == "system" and len(msg) == 1:
       ~~~~~~^^^^^^^^
TypeError: 'NoneType' object is not subscriptable
2024-01-23 18:26:33.080 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 258, in display_chat_history_sidebar
    if msg[0]["role"] == "system" and len(msg) == 1:
       ~~~~~~^^^^^^^^
TypeError: 'NoneType' object is not subscriptable
2024-01-23 18:26:45.233 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 258, in display_chat_history_sidebar
    if msg[0]["role"] == "system" and len(msg) == 1:
       ~~~~~~^^^^^^^^
TypeError: 'NoneType' object is not subscriptable
2024-01-23 18:27:14.404 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 258, in display_chat_history_sidebar
    if msg[0]["role"] == "system" and len(msg) == 1:
       ~~~~~~^^^^^^^^
TypeError: 'NoneType' object is not subscriptable
2024-01-23 18:28:00.288 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 370, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 259, in display_chat_history_sidebar
    if msg[0]["role"] == "system" and len(msg) == 1:
       ~~~~~~^^^^^^^^
TypeError: 'NoneType' object is not subscriptable
2024-01-23 18:29:44.517 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 363, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 258, in display_chat_history_sidebar
    date = parse_date(msg[0]['date'])
                      ^^^
NameError: name 'msg' is not defined
2024-01-23 18:33:18.194 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 358, in <module>
    display_chat_history_sidebar(chat_history)
TypeError: display_chat_history_sidebar() takes 0 positional arguments but 1 was given
2024-01-23 18:34:12.441 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 358, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 257, in display_chat_history_sidebar
    grouped_by_date[date].append((subject, chatID))
    ^^^^^^^^^^^^^^^
NameError: name 'grouped_by_date' is not defined
2024-01-23 18:35:56.221 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 359, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 258, in display_chat_history_sidebar
    grouped_by_date[date].append((subject, chatID))
    ^^^^^^^^^^^^^^^
NameError: name 'grouped_by_date' is not defined
2024-01-23 18:36:29.660 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 360, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 259, in display_chat_history_sidebar
    grouped_by_date[date].append((subject, chatID))
    ~~~~~~~~~~~~~~~^^^^^^
TypeError: unhashable type: 'Series'
2024-01-23 18:38:46.483 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 361, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 260, in display_chat_history_sidebar
    grouped_by_date[date].append((subject, chatID))
    ~~~~~~~~~~~~~~~^^^^^^
TypeError: unhashable type: 'Series'
2024-01-23 18:40:03.204 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 361, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 258, in display_chat_history_sidebar
    for rowno, subject, date in subjects.iterrows():
        ^^^^^^^^^^^^^^^^^^^^
ValueError: not enough values to unpack (expected 3, got 2)
2024-01-23 18:41:47.851 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 362, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 259, in display_chat_history_sidebar
    for s in subject.iterrows():
             ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/generic.py", line 6204, in __getattr__
    return object.__getattribute__(self, name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'Series' object has no attribute 'iterrows'
2024-01-23 18:42:39.692 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 362, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 258, in display_chat_history_sidebar
    for _, subject in subjects:
        ^^^^^^^^^^
ValueError: too many values to unpack (expected 2)
2024-01-23 18:43:01.622 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 362, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 259, in display_chat_history_sidebar
    for s,a in subject:
        ^^^
ValueError: too many values to unpack (expected 2)
/root/cs50p/project/main.py:259: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  for s,a in subject:
2024-01-23 18:45:16.645 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 361, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 259, in display_chat_history_sidebar
    date = subject["date"]
           ~~~~~~~^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 18:46:06.521 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 362, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 259, in display_chat_history_sidebar
    date = subject["date"]
           ~~~~~~~^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 18:46:35.525 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 362, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 261, in display_chat_history_sidebar
    grouped_by_date[date].append((subject, chatID))
    ~~~~~~~~~~~~~~~^^^^^^
KeyError: '2024-01-22'
2024-01-23 18:46:55.291 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 362, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 261, in display_chat_history_sidebar
    grouped_by_date[date].append((subject, chatID))
    ~~~~~~~~~~~~~~~^^^^^^
KeyError: 'Yesterday'
2024-01-23 18:47:11.325 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 365, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 264, in display_chat_history_sidebar
    grouped_by_date[date].append((subject, chatID))
                                           ^^^^^^
UnboundLocalError: cannot access local variable 'chatID' where it is not associated with a value
2024-01-23 18:47:59.838 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 365, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 264, in display_chat_history_sidebar
    grouped_by_date[date].append((subject, chatID))
                                           ^^^^^^
UnboundLocalError: cannot access local variable 'chatID' where it is not associated with a value
2024-01-23 18:48:52.692 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 272, in display_chat_history_sidebar
    if st.button(label=subject, key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-23 18:49:25.450 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 272, in display_chat_history_sidebar
    if st.button(label=subject, key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-23 18:49:55.753 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 272, in display_chat_history_sidebar
    if st.button(label=subject, key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-23 18:50:26.133 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 366, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 272, in display_chat_history_sidebar
    if st.button(label=subject, key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-23 18:51:14.293 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 372, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 278, in display_chat_history_sidebar
    if st.button(label=subject, key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-23 18:52:05.069 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 373, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 279, in display_chat_history_sidebar
    if st.button(label=subject, key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-23 18:52:57.731 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 373, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 279, in display_chat_history_sidebar
    if st.button(label=subject, key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-23 18:53:39.028 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3791, in get_loc
    return self._engine.get_loc(casted_key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "index.pyx", line 152, in pandas._libs.index.IndexEngine.get_loc
  File "index.pyx", line 181, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'e86e0c90-dec2-4bdb-aea9-fe63c8e30e42'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 371, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 284, in display_chat_history_sidebar
    hstr = chat[chatID]
           ~~~~^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/frame.py", line 3893, in __getitem__
    indexer = self.columns.get_loc(key)
              ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3798, in get_loc
    raise KeyError(key) from err
KeyError: 'e86e0c90-dec2-4bdb-aea9-fe63c8e30e42'
2024-01-23 18:54:38.917 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3791, in get_loc
    return self._engine.get_loc(casted_key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "index.pyx", line 152, in pandas._libs.index.IndexEngine.get_loc
  File "index.pyx", line 181, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'e86e0c90-dec2-4bdb-aea9-fe63c8e30e42'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 372, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 285, in display_chat_history_sidebar
    hstr = chat[chatID]
           ~~~~^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/frame.py", line 3893, in __getitem__
    indexer = self.columns.get_loc(key)
              ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3798, in get_loc
    raise KeyError(key) from err
KeyError: 'e86e0c90-dec2-4bdb-aea9-fe63c8e30e42'
2024-01-23 18:55:28.413 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    True if message["role"] == "user" else False,
            ~~~~~~~^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 18:57:42.160 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 378, in <module>
    True if message["role"] == "user" else False,
            ~~~~~~~^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 18:57:50.760 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 372, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 285, in display_chat_history_sidebar
    message = {"role": line["role"], "content": line["content"], "chatID": chatID, "date": date.isoformat(), "messageID": line["messageID"]}
                       ~~~~^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 18:58:20.149 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 373, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 286, in display_chat_history_sidebar
    message = {"role": line["role"], "content": line["content"], "chatID": chatID, "date": date.isoformat(), "messageID": line["messageID"]}
                       ~~~~^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 18:58:50.541 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 374, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 287, in display_chat_history_sidebar
    message = {"role": line["role"], "content": line["content"], "chatID": chatID, "date": date.isoformat(), "messageID": line["messageID"]}
                       ~~~~^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 18:59:07.602 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 374, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 287, in display_chat_history_sidebar
    message = {"role": line["role"], "content": line["content"], "chatID": chatID, "date": date.isoformat(), "messageID": line["messageID"]}
                       ~~~~^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 18:59:23.399 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 374, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 286, in display_chat_history_sidebar
    st.write(line["messageID"])
             ~~~~^^^^^^^^^^^^^
TypeError: tuple indices must be integers or slices, not str
2024-01-23 19:00:14.355 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 374, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 286, in display_chat_history_sidebar
    st.write(line["messageID"])
             ~~~~^^^^^^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 19:00:59.637 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 373, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 286, in display_chat_history_sidebar
    message = {"role": line["role"], "content": line["content"], "chatID": chatID, "date": date.isoformat(), "messageID": line["messageID"]}
                       ~~~~^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 19:02:13.272 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 373, in <module>
    display_chat_history_sidebar(chat_history)
  File "/root/cs50p/project/main.py", line 286, in display_chat_history_sidebar
    message = {"role": line["role"], "content": line["content"], "chatID": chatID, "date": date.isoformat(), "messageID": line["messageID"]}
                                                                                           ^^^^^^^^^^^^^^
AttributeError: 'str' object has no attribute 'isoformat'
2024-01-23 19:02:37.472 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3791, in get_loc
    return self._engine.get_loc(casted_key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "index.pyx", line 152, in pandas._libs.index.IndexEngine.get_loc
  File "index.pyx", line 181, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'counter'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 122, in message_func
    if message["counter"] > 1:
       ~~~~~~~^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/series.py", line 1040, in __getitem__
    return self._get_value(key)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/series.py", line 1156, in _get_value
    loc = self.index.get_loc(label)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3798, in get_loc
    raise KeyError(key) from err
KeyError: 'counter'
2024-01-23 19:03:19.751 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3791, in get_loc
    return self._engine.get_loc(casted_key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "index.pyx", line 152, in pandas._libs.index.IndexEngine.get_loc
  File "index.pyx", line 181, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'counter'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 122, in message_func
    if message["counter"] > 1:
       ~~~~~~~^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/series.py", line 1040, in __getitem__
    return self._get_value(key)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/series.py", line 1156, in _get_value
    loc = self.index.get_loc(label)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3798, in get_loc
    raise KeyError(key) from err
KeyError: 'counter'
2024-01-23 19:03:21.624 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3791, in get_loc
    return self._engine.get_loc(casted_key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "index.pyx", line 152, in pandas._libs.index.IndexEngine.get_loc
  File "index.pyx", line 181, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'counter'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 122, in message_func
    if message["counter"] > 1:
       ~~~~~~~^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/series.py", line 1040, in __getitem__
    return self._get_value(key)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/series.py", line 1156, in _get_value
    loc = self.index.get_loc(label)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3798, in get_loc
    raise KeyError(key) from err
KeyError: 'counter'
2024-01-23 19:03:46.254 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3791, in get_loc
    return self._engine.get_loc(casted_key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "index.pyx", line 152, in pandas._libs.index.IndexEngine.get_loc
  File "index.pyx", line 181, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'counter'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 375, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 122, in message_func
    if message["counter"] > 1:
       ~~~~~~~^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/series.py", line 1040, in __getitem__
    return self._get_value(key)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/series.py", line 1156, in _get_value
    loc = self.index.get_loc(label)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3798, in get_loc
    raise KeyError(key) from err
KeyError: 'counter'
2024-01-23 19:29:32.185 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 369, in <module>
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 276, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
                       ~~~~~~~^^^^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 19:30:09.242 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 370, in <module>
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 265, in display_chat_history_sidebar
    date = parse_date(subject["date"])
                      ~~~~~~~^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 19:30:22.259 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 370, in <module>
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 277, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
                       ~~~~~~~^^^^^^^^^^^
TypeError: string indices must be integers, not 'str'
2024-01-23 19:36:53.673 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 264, in _get_or_create_cached_value
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 312, in _handle_cache_miss
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: no such column: m.date_add

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 370, in <module>
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 262, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=1)
               ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 238, in query
    return _query(
           ^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 212, in wrapper
    return cached_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 241, in __call__
    return self._get_or_create_cached_value(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 267, in _get_or_create_cached_value
    return self._handle_cache_miss(cache, value_key, func_args, func_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 321, in _handle_cache_miss
    computed_value = self._info.func(*func_args, **func_kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 289, in wrapped_f
    return self(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 379, in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 325, in iter
    raise retry_exc.reraise()
          ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 158, in reraise
    raise self.last_attempt.result()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 382, in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 216, in _query
    return pd.read_sql(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 682, in read_sql
    return pandas_sql.read_query(
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1776, in read_query
    result = self.execute(sql, params)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1600, in execute
    return self.con.execute(sql, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1380, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such column: m.date_add
[SQL: 
            SELECT DISTINCT s.subject,m.date,s.chatID 
            FROM subject s 
            JOIN messages m ON s.chatID = m.chatID 
            ORDER BY m.date_add DESC;
            ]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-23 19:46:32.166 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 379, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 125, in message_func
    result = conn.query(sql,{"chatID":chatID})
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: SQLConnection.query() takes 2 positional arguments but 3 were given
2024-01-23 19:50:00.151 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3791, in get_loc
    return self._engine.get_loc(casted_key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "index.pyx", line 152, in pandas._libs.index.IndexEngine.get_loc
  File "index.pyx", line 181, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 1

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 380, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 126, in message_func
    st.write(result[1])
             ~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/frame.py", line 3893, in __getitem__
    indexer = self.columns.get_loc(key)
              ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3798, in get_loc
    raise KeyError(key) from err
KeyError: 1
2024-01-23 19:50:10.517 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3791, in get_loc
    return self._engine.get_loc(casted_key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "index.pyx", line 152, in pandas._libs.index.IndexEngine.get_loc
  File "index.pyx", line 181, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 380, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 126, in message_func
    st.write(result[0])
             ~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/frame.py", line 3893, in __getitem__
    indexer = self.columns.get_loc(key)
              ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3798, in get_loc
    raise KeyError(key) from err
KeyError: 0
2024-01-23 19:51:07.392 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 375, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 128, in message_func
    chat = load_chat_history_sql(chatID_filter=chatID, messageID_edit=messageID)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 249, in load_chat_history_sql
    return chat_history
           ^^^^^^^^^^^^
UnboundLocalError: cannot access local variable 'chat_history' where it is not associated with a value
2024-01-23 19:53:07.365 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 376, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 128, in message_func
    chat = load_chat_history_sql(chatID_filter=chatID, messageID_edit=messageID)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 250, in load_chat_history_sql
    return chat_history
           ^^^^^^^^^^^^
UnboundLocalError: cannot access local variable 'chat_history' where it is not associated with a value
2024-01-23 19:54:10.666 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 393, in <module>
    for item in response:
  File "/root/cs50p/project/gpt4free/g4f/Provider/base_provider.py", line 149, in create_completion
    yield loop.run_until_complete(gen.__anext__())
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/Bing.py", line 503, in stream_generate
    raise Exception(f"{result['value']}: {result['message']}")
Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.
2024-01-23 19:55:19.920 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 393, in <module>
    for item in response:
  File "/root/cs50p/project/gpt4free/g4f/Provider/base_provider.py", line 149, in create_completion
    yield loop.run_until_complete(gen.__anext__())
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/Bing.py", line 503, in stream_generate
    raise Exception(f"{result['value']}: {result['message']}")
Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.
2024-01-23 21:18:32.516 Session with id e4994e0d-bf0e-4b8a-b290-68454744b790 is already connected! Connecting to a new session.
2024-01-24 19:23:32.807 Session with id f1944719-a29c-4e83-867f-65bb49ed23ef is already connected! Connecting to a new session.
2024-01-24 19:25:27.180 Session with id 5ea9e0c1-b2c9-4f4d-84d4-735b319b412d is already connected! Connecting to a new session.
2024-01-25 09:24:32.623 Session with id 9a7a7387-5f9e-4ea5-9526-3b49e266f053 is already connected! Connecting to a new session.
2024-01-25 12:17:23.285 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 362, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    subject = get_subject_message(prompt)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 176, in get_subject_message
    subject = str(get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo))
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 73, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-25 12:24:07.658 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 264, in _get_or_create_cached_value
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 312, in _handle_cache_miss
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: no such table: message

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 384, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 122, in message_func
    messageno = conn.query(sql, params={"chatID":chatID,"messageID":messageID})
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 238, in query
    return _query(
           ^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 212, in wrapper
    return cached_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 241, in __call__
    return self._get_or_create_cached_value(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 267, in _get_or_create_cached_value
    return self._handle_cache_miss(cache, value_key, func_args, func_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 321, in _handle_cache_miss
    computed_value = self._info.func(*func_args, **func_kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 289, in wrapped_f
    return self(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 379, in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 325, in iter
    raise retry_exc.reraise()
          ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 158, in reraise
    raise self.last_attempt.result()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 382, in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 216, in _query
    return pd.read_sql(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 682, in read_sql
    return pandas_sql.read_query(
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1776, in read_query
    result = self.execute(sql, params)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1600, in execute
    return self.con.execute(sql, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1380, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: message
[SQL: 
        SELECT rownum FROM 
        (SELECT ROW_NUMBER() OVER (PARTITION BY chatID ORDER BY add_date) as rownum
        ,   messageID
        FROM message WHERE chatID = ?) src
        WHERE messageID = ?;"
        ]
[parameters: ('7d5413de-173f-4b06-9d95-13a090b12984', 'db399281-d2a6-423b-9950-2b61b3ca5355')]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-25 12:24:21.972 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 264, in _get_or_create_cached_value
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 312, in _handle_cache_miss
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: You can only execute one statement at a time.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 384, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 122, in message_func
    messageno = conn.query(sql, params={"chatID":chatID,"messageID":messageID})
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 238, in query
    return _query(
           ^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 212, in wrapper
    return cached_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 241, in __call__
    return self._get_or_create_cached_value(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 267, in _get_or_create_cached_value
    return self._handle_cache_miss(cache, value_key, func_args, func_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 321, in _handle_cache_miss
    computed_value = self._info.func(*func_args, **func_kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 289, in wrapped_f
    return self(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 379, in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 325, in iter
    raise retry_exc.reraise()
          ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 158, in reraise
    raise self.last_attempt.result()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 382, in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 216, in _query
    return pd.read_sql(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 682, in read_sql
    return pandas_sql.read_query(
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1776, in read_query
    result = self.execute(sql, params)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1600, in execute
    return self.con.execute(sql, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1380, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) You can only execute one statement at a time.
[SQL: 
        SELECT rownum FROM 
        (SELECT ROW_NUMBER() OVER (PARTITION BY chatID ORDER BY add_date) as rownum
        ,   messageID
        FROM messages WHERE chatID = ?) src
        WHERE messageID = ?;"
        ]
[parameters: ('7d5413de-173f-4b06-9d95-13a090b12984', 'db399281-d2a6-423b-9950-2b61b3ca5355')]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-25 12:34:21.881 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 264, in _get_or_create_cached_value
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 312, in _handle_cache_miss
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: near "1": syntax error

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 383, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 121, in message_func
    messageno = conn.query(sql, params={"chatID":chatID})
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 238, in query
    return _query(
           ^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 212, in wrapper
    return cached_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 241, in __call__
    return self._get_or_create_cached_value(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 267, in _get_or_create_cached_value
    return self._handle_cache_miss(cache, value_key, func_args, func_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 321, in _handle_cache_miss
    computed_value = self._info.func(*func_args, **func_kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 289, in wrapped_f
    return self(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 379, in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 325, in iter
    raise retry_exc.reraise()
          ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 158, in reraise
    raise self.last_attempt.result()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 382, in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 216, in _query
    return pd.read_sql(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 682, in read_sql
    return pandas_sql.read_query(
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1776, in read_query
    result = self.execute(sql, params)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1600, in execute
    return self.con.execute(sql, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1380, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) near "1": syntax error
[SQL: 
        SELECT TOP 1 messageID
        FROM messages WHERE chatID = ?
        AND role = 'user'
        ORDER BY add_date DESC;
        ]
[parameters: ('7d5413de-173f-4b06-9d95-13a090b12984',)]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-25 12:36:27.086 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 384, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 130, in message_func
    if messageno["messageID"] != messageID:
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/generic.py", line 1519, in __nonzero__
    raise ValueError(
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2024-01-25 12:36:52.182 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3791, in get_loc
    return self._engine.get_loc(casted_key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "index.pyx", line 152, in pandas._libs.index.IndexEngine.get_loc
  File "index.pyx", line 181, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 384, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 130, in message_func
    if messageno[0]["messageID"] != messageID:
       ~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/frame.py", line 3893, in __getitem__
    indexer = self.columns.get_loc(key)
              ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3798, in get_loc
    raise KeyError(key) from err
KeyError: 0
2024-01-25 12:38:04.928 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3791, in get_loc
    return self._engine.get_loc(casted_key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "index.pyx", line 152, in pandas._libs.index.IndexEngine.get_loc
  File "index.pyx", line 181, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 385, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 123, in message_func
    st.write(messageno[0])
             ~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/frame.py", line 3893, in __getitem__
    indexer = self.columns.get_loc(key)
              ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexes/base.py", line 3798, in get_loc
    raise KeyError(key) from err
KeyError: 0
2024-01-25 12:40:31.341 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 385, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 123, in message_func
    st.write(messageno.iloc(messageno))
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 722, in __call__
    axis_int_none = self.obj._get_axis_number(axis)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/generic.py", line 552, in _get_axis_number
    return cls._AXIS_TO_AXIS_NUMBER[axis]
           ~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^
TypeError: unhashable type: 'DataFrame'
/root/cs50p/project/main.py:123: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.write(messageno.iloc(messageno))
/root/cs50p/project/main.py:123: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.write(messageno.iloc(messageno))
/root/cs50p/project/main.py:130: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:130: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:130: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:130: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:130: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # if messageno["messageID"] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # if messageno["messageID"] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # if messageno["messageID"] != messageID:
/root/cs50p/project/main.py:140: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #delete current message, to be replaced with the edited one
2024-01-25 12:47:01.765 Thread 'Thread-4602 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:47:01.765 Thread 'Thread-4602 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:47:01.766 Thread 'Thread-4602 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:47:02.267 Thread 'Thread-4603': missing ScriptRunContext
2024-01-25 12:47:09.413 Thread 'Thread-4602 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:47:09.413 Thread 'Thread-4602 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:47:09.413 Thread 'Thread-4602 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:47:09.413 Thread 'Thread-4602 (get_subject_message)': missing ScriptRunContext
Exception in thread Thread-4602 (get_subject_message):
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 394, in __getitem__
    return self._getitem(widget_id, key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 439, in _getitem
    raise KeyError
KeyError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "/root/anaconda3/envs/cs50/lib/python3.11/threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "/root/cs50p/project/main.py", line 202, in get_subject_message
    s.execute(sql, {'chatID': st.session_state["chatID"], 'subject': subject})
                              ~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 90, in __getitem__
    return get_session_state()[key]
           ~~~~~~~~~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/safe_session_state.py", line 89, in __getitem__
    return self._state[key]
           ~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 396, in __getitem__
    raise KeyError(_missing_key_error_message(key))
KeyError: 'st.session_state has no key "chatID". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization'
2024-01-25 12:47:09.422 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 394, in __getitem__
    return self._getitem(widget_id, key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 439, in _getitem
    raise KeyError
KeyError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 380, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 59, in get_user_input
    subject = st.session_state["subject"]
              ~~~~~~~~~~~~~~~~^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 90, in __getitem__
    return get_session_state()[key]
           ~~~~~~~~~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/safe_session_state.py", line 89, in __getitem__
    return self._state[key]
           ~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 396, in __getitem__
    raise KeyError(_missing_key_error_message(key))
KeyError: 'st.session_state has no key "subject". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization'
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  messageno = conn.query(sql, params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  messageno = conn.query(sql, params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  messageno = conn.query(sql, params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:140: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 12:48:25.013 Thread 'Thread-4627 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:48:25.013 Thread 'Thread-4627 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:48:25.014 Thread 'Thread-4627 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:48:25.514 Thread 'Thread-4628': missing ScriptRunContext
2024-01-25 12:48:31.956 Thread 'Thread-4627 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:48:31.956 Thread 'Thread-4627 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:48:31.956 Thread 'Thread-4627 (get_subject_message)': missing ScriptRunContext
2024-01-25 12:48:31.957 Thread 'Thread-4627 (get_subject_message)': missing ScriptRunContext
Exception in thread Thread-4627 (get_subject_message):
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 394, in __getitem__
    return self._getitem(widget_id, key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 439, in _getitem
    raise KeyError
KeyError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "/root/anaconda3/envs/cs50/lib/python3.11/threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "/root/cs50p/project/main.py", line 202, in get_subject_message
    s.execute(sql, {'chatID': st.session_state["chatID"], 'subject': subject})
                              ~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 90, in __getitem__
    return get_session_state()[key]
           ~~~~~~~~~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/safe_session_state.py", line 89, in __getitem__
    return self._state[key]
           ~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 396, in __getitem__
    raise KeyError(_missing_key_error_message(key))
KeyError: 'st.session_state has no key "chatID". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization'
2024-01-25 12:48:31.960 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 394, in __getitem__
    return self._getitem(widget_id, key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 439, in _getitem
    raise KeyError
KeyError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 380, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 59, in get_user_input
    subject = st.session_state["subject"]
              ~~~~~~~~~~~~~~~~^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 90, in __getitem__
    return get_session_state()[key]
           ~~~~~~~~~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/safe_session_state.py", line 89, in __getitem__
    return self._state[key]
           ~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 396, in __getitem__
    raise KeyError(_missing_key_error_message(key))
KeyError: 'st.session_state has no key "subject". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization'
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  messageno = conn.query(sql, params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 14:13:08.930 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 386, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 136, in message_func
    st.session_state["subject"] = message["subject"]
                                  ~~~~~~~^^^^^^^^^^^
KeyError: 'subject'
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 14:15:27.090 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 264, in _get_or_create_cached_value
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 312, in _handle_cache_miss
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1800, in _execute_context
    context = constructor(
              ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 995, in _init_compiled
    compiled.construct_params(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py", line 1062, in construct_params
    raise exc.InvalidRequestError(
sqlalchemy.exc.InvalidRequestError: A value is required for bind parameter 'chatID' (Background on this error at: https://sqlalche.me/e/14/cd3x)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 387, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 137, in message_func
    message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 238, in query
    return _query(
           ^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 212, in wrapper
    return cached_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 241, in __call__
    return self._get_or_create_cached_value(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 267, in _get_or_create_cached_value
    return self._handle_cache_miss(cache, value_key, func_args, func_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 321, in _handle_cache_miss
    computed_value = self._info.func(*func_args, **func_kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 289, in wrapped_f
    return self(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 379, in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 314, in iter
    return fut.result()
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 382, in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 216, in _query
    return pd.read_sql(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 682, in read_sql
    return pandas_sql.read_query(
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1776, in read_query
    result = self.execute(sql, params)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1600, in execute
    return self.con.execute(sql, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1380, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1806, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1800, in _execute_context
    context = constructor(
              ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 995, in _init_compiled
    compiled.construct_params(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py", line 1062, in construct_params
    raise exc.InvalidRequestError(
sqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is required for bind parameter 'chatID'
[SQL: SELECT subject FROM subject WHERE chatID = ?;]
(Background on this error at: https://sqlalche.me/e/14/cd3x)
Exception during reset or similar
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/pool/base.py", line 763, in _finalize_fairy
    fairy._reset(pool, transaction_was_reset)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/pool/base.py", line 1038, in _reset
    pool._dialect.do_rollback(self)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 683, in do_rollback
    dbapi_connection.rollback()
sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 139679986874112 and this is thread id 139680163022592.
Exception closing connection <sqlite3.Connection object at 0x7f0a40777a60>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/pool/base.py", line 763, in _finalize_fairy
    fairy._reset(pool, transaction_was_reset)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/pool/base.py", line 1038, in _reset
    pool._dialect.do_rollback(self)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 683, in do_rollback
    dbapi_connection.rollback()
sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 139679986874112 and this is thread id 139680163022592.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/pool/base.py", line 260, in _close_connection
    self._dialect.do_terminate(connection)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 689, in do_terminate
    self.do_close(dbapi_connection)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 692, in do_close
    dbapi_connection.close()
sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 139679986874112 and this is thread id 139680163022592.
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
2024-01-25 14:16:03.227 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 387, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 139, in message_func
    chat = load_chat_history_sql(chatID_filter=chatID, messageID_edit=messageID)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 261, in load_chat_history_sql
    return chat_history
           ^^^^^^^^^^^^
UnboundLocalError: cannot access local variable 'chat_history' where it is not associated with a value
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
2024-01-25 14:29:19.285 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: near ">": syntax error

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 386, in <module>
    message_func(
  File "/root/cs50p/project/main.py", line 141, in message_func
    save_or_delete_message_in_sql(chatID=chatID,messageID=messageID)
  File "/root/cs50p/project/main.py", line 232, in save_or_delete_message_in_sql
    s.execute(sql, {"chatID":chatID,"messageID":messageID})
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) near ">": syntax error
[SQL: DELETE FROM messages WHERE chatID = ? AND add_date => (SELECT add_date FROM messages WHERE messageID = ?);]
[parameters: ('93fc7b9e-6987-4d69-8350-3e6a818980ed', 'bd66e34c-e9d9-4056-b451-c18d46dd4bf8')]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:368: RuntimeWarning: coroutine 'get_user_input' was never awaited
  st.session_state["chat_react"] = False
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:134: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
/root/cs50p/project/main.py:134: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
/root/cs50p/project/main.py:368: RuntimeWarning: coroutine 'get_user_input' was never awaited
  st.session_state["chat_react"] = False
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:134: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
/root/cs50p/project/main.py:134: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
/root/cs50p/project/main.py:134: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
/root/cs50p/project/main.py:134: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
/root/cs50p/project/main.py:134: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
/root/cs50p/project/main.py:134: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
Task was destroyed but it is pending!
task: <Task pending name='Task-380552' coro=<get_subject_message() running at /root/cs50p/project/main.py:174>>
/root/anaconda3/envs/cs50/lib/python3.11/asyncio/base_events.py:678: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  self._ready.clear()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:134: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  st.session_state["instructionID"] = generate_random_identifier()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  st.session_state["instructionID"] = generate_random_identifier()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  st.session_state["instructionID"] = generate_random_identifier()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 14:53:14.260 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1800, in _execute_context
    context = constructor(
              ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1001, in _init_compiled
    self.compiled_parameters = [
                               ^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1002, in <listcomp>
    compiled.construct_params(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py", line 1062, in construct_params
    raise exc.InvalidRequestError(
sqlalchemy.exc.InvalidRequestError: A value is required for bind parameter 'messageID' (Background on this error at: https://sqlalche.me/e/14/cd3x)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 416, in <module>
    save_or_delete_message_in_sql(chatID=chatID,delete_all=False)
  File "/root/cs50p/project/main.py", line 232, in save_or_delete_message_in_sql
    s.execute(sql, message)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1806, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1800, in _execute_context
    context = constructor(
              ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1001, in _init_compiled
    self.compiled_parameters = [
                               ^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1002, in <listcomp>
    compiled.construct_params(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py", line 1062, in construct_params
    raise exc.InvalidRequestError(
sqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is required for bind parameter 'messageID'
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date,add_date)
                VALUES(?, ?, ?, ?, ?,CURRENT_TIMESTAMP);
                ]
[parameters: [{}]]
(Background on this error at: https://sqlalche.me/e/14/cd3x)
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-25 15:17:39.523 Session with id e3647ccf-2909-4d19-9cf6-372c4191b46f is already connected! Connecting to a new session.
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:365: RuntimeWarning: coroutine 'get_user_input' was never awaited
  get_user_input()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:50: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  get_subject_message(prompt)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:131: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 15:25:11.036 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 365, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    asyncio.run(get_subject_message(prompt))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 181, in get_subject_message
    subject = await(str(get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo)))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object str can't be used in 'await' expression
2024-01-25 15:26:13.353 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 365, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    asyncio.run(get_subject_message(prompt))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 181, in get_subject_message
    subject = await(str(get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo,stream=True)))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object str can't be used in 'await' expression
2024-01-25 15:26:31.937 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 365, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    asyncio.run(get_subject_message(prompt))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 181, in get_subject_message
    subject = await(get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo,stream=True))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object generator can't be used in 'await' expression
2024-01-25 15:27:04.280 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 365, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    asyncio.run(get_subject_message(prompt))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 181, in get_subject_message
    subject = await(get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object str can't be used in 'await' expression
/root/cs50p/project/main.py:152: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  else:
/root/cs50p/project/main.py:152: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  else:
2024-01-25 15:30:27.913 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1800, in _execute_context
    context = constructor(
              ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1001, in _init_compiled
    self.compiled_parameters = [
                               ^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1002, in <listcomp>
    compiled.construct_params(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py", line 1062, in construct_params
    raise exc.InvalidRequestError(
sqlalchemy.exc.InvalidRequestError: A value is required for bind parameter 'messageID' (Background on this error at: https://sqlalche.me/e/14/cd3x)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 437, in <module>
    save_or_delete_message_in_sql(chatID=chatID,delete_all=False)
  File "/root/cs50p/project/main.py", line 253, in save_or_delete_message_in_sql
    s.execute(sql, message)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1806, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1800, in _execute_context
    context = constructor(
              ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1001, in _init_compiled
    self.compiled_parameters = [
                               ^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1002, in <listcomp>
    compiled.construct_params(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py", line 1062, in construct_params
    raise exc.InvalidRequestError(
sqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is required for bind parameter 'messageID'
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date,add_date)
                VALUES(?, ?, ?, ?, ?,CURRENT_TIMESTAMP);
                ]
[parameters: [{}]]
(Background on this error at: https://sqlalche.me/e/14/cd3x)
/root/cs50p/project/main.py:152: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:152: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 15:30:33.976 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1800, in _execute_context
    context = constructor(
              ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1001, in _init_compiled
    self.compiled_parameters = [
                               ^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1002, in <listcomp>
    compiled.construct_params(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py", line 1062, in construct_params
    raise exc.InvalidRequestError(
sqlalchemy.exc.InvalidRequestError: A value is required for bind parameter 'messageID' (Background on this error at: https://sqlalche.me/e/14/cd3x)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 437, in <module>
    save_or_delete_message_in_sql(chatID=chatID,delete_all=False)
  File "/root/cs50p/project/main.py", line 253, in save_or_delete_message_in_sql
    s.execute(sql, message)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1806, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1800, in _execute_context
    context = constructor(
              ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1001, in _init_compiled
    self.compiled_parameters = [
                               ^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1002, in <listcomp>
    compiled.construct_params(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py", line 1062, in construct_params
    raise exc.InvalidRequestError(
sqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is required for bind parameter 'messageID'
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date,add_date)
                VALUES(?, ?, ?, ?, ?,CURRENT_TIMESTAMP);
                ]
[parameters: [{}]]
(Background on this error at: https://sqlalche.me/e/14/cd3x)
/root/cs50p/project/main.py:152: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  LIMIT 1;
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  LIMIT 1;
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  LIMIT 1;
2024-01-25 15:33:39.758 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1800, in _execute_context
    context = constructor(
              ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1001, in _init_compiled
    self.compiled_parameters = [
                               ^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1002, in <listcomp>
    compiled.construct_params(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py", line 1062, in construct_params
    raise exc.InvalidRequestError(
sqlalchemy.exc.InvalidRequestError: A value is required for bind parameter 'messageID' (Background on this error at: https://sqlalche.me/e/14/cd3x)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 423, in <module>
    save_or_delete_message_in_sql(chatID=chatID,delete_all=False)
  File "/root/cs50p/project/main.py", line 239, in save_or_delete_message_in_sql
    s.execute(sql, message)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1806, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1800, in _execute_context
    context = constructor(
              ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1001, in _init_compiled
    self.compiled_parameters = [
                               ^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 1002, in <listcomp>
    compiled.construct_params(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/compiler.py", line 1062, in construct_params
    raise exc.InvalidRequestError(
sqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is required for bind parameter 'messageID'
[SQL: 
                INSERT INTO messages(messageID,chatID,role,content,date,add_date)
                VALUES(?, ?, ?, ?, ?,CURRENT_TIMESTAMP);
                ]
[parameters: [{}]]
(Background on this error at: https://sqlalche.me/e/14/cd3x)
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 15:35:29.420 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 372, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    asyncio.run(get_subject_message(prompt))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 188, in get_subject_message
    subject = await get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo,stream=True)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object generator can't be used in 'await' expression
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 15:40:50.749 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    loop.run_until_complete(get_streaming_response())
                            ^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: get_streaming_response() missing 1 required positional argument: 'messages'
2024-01-25 15:41:05.710 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    loop.run_until_complete(get_streaming_response(_async=True))
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: get_streaming_response() missing 1 required positional argument: 'messages'
2024-01-25 15:41:13.209 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    loop.run_until_complete(get_streaming_response(None,_async=True))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 80, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-25 15:41:21.220 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    loop.run_until_complete(get_streaming_response(None,_async=True))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 80, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-25 15:41:22.697 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 377, in <module>
    loop.run_until_complete(get_streaming_response(None,_async=True))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 80, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-25 15:44:15.798 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 372, in <module>
    get_user_input()
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    asyncio.run(get_subject_message(prompt))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 188, in get_subject_message
    subject = await get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo,_async=True)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/__init__.py", line 95, in create_async
    return await provider.create_async(model.name, messages, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 84, in create_async
    self.raise_exceptions()
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 88, in raise_exceptions
    raise RetryProviderError("RetryProvider failed:\n" + "\n".join([
gpt4free.g4f.errors.RetryProviderError: RetryProvider failed:
ChatAnywhere: ClientResponseError: 522, message='', url=URL('https://chatanywhere.cn/v1/chat/gpt/')
GptForLove: RuntimeUnavailableError: Could not find an available JavaScript runtime.
You: RequestsError: HTTP Error 403: 
Chatgpt4Online: RuntimeError: No nonce found
ChatBase: ClientResponseError: 500, message='Internal Server Error', url=URL('https://www.chatbase.co/api/fe/chat')
GptGo: ClientResponseError: 403, message='Forbidden', url=URL('https://gptgo.ai/get_token.php')
2024-01-25 15:48:20.403 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Error binding parameter 2: type 'coroutine' is not supported

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 372, in <module>
    asyncio.run(get_user_input())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    await get_subject_message(prompt)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 195, in get_subject_message
    s.execute(sql, {'chatID': st.session_state["chatID"], 'subject': subject})
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Error binding parameter 2: type 'coroutine' is not supported
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?, ?);
                ]
[parameters: ('03a15a8a-a336-4d9a-bfc8-2d48e1df00fa', <coroutine object ChatCompletion.create_async at 0x7f0a40f05be0>)]
(Background on this error at: https://sqlalche.me/e/14/f405)
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'ChatCompletion.create_async' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:50: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  await get_subject_message(prompt)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:50: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  await get_subject_message(prompt)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:372: RuntimeWarning: coroutine 'get_user_input' was never awaited
  asyncio.run(get_user_input())
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:372: RuntimeWarning: coroutine 'get_user_input' was never awaited
  asyncio.run(get_user_input())
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:372: RuntimeWarning: coroutine 'get_user_input' was never awaited
  asyncio.run(get_user_input())
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-25 16:16:58.813 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Error binding parameter 2: type 'coroutine' is not supported

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 372, in <module>
    asyncio.run(get_user_input())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    await get_subject_message(prompt)
  File "/root/cs50p/project/main.py", line 195, in get_subject_message
    s.execute(sql, {'chatID': st.session_state["chatID"], 'subject': subject})
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Error binding parameter 2: type 'coroutine' is not supported
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?, ?);
                ]
[parameters: ('cccf35e6-de8e-4945-98bd-832f2971e6b6', <coroutine object ChatCompletion.create_async at 0x7f0a2a059470>)]
(Background on this error at: https://sqlalche.me/e/14/f405)
<frozen _collections_abc>:836: RuntimeWarning: coroutine 'ChatCompletion.create_async' was never awaited
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-25 16:18:45.226 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Error binding parameter 2: type 'coroutine' is not supported

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 372, in <module>
    asyncio.run(get_user_input())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    await get_subject_message(prompt)
  File "/root/cs50p/project/main.py", line 195, in get_subject_message
    s.execute(sql, {'chatID': st.session_state["chatID"], 'subject': subject})
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/orm/session.py", line 1714, in execute
    result = conn._execute_20(statement, params or {}, execution_options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1705, in _execute_20
    return meth(self, args_10style, kwargs_10style, execution_options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Error binding parameter 2: type 'coroutine' is not supported
[SQL: 
                INSERT INTO subject(chatID,subject)
                VALUES(?, ?);
                ]
[parameters: ('da3c9802-ea1d-41b9-b60c-380474dd08b4', <coroutine object get_streaming_response at 0x7f0a40d29340>)]
(Background on this error at: https://sqlalche.me/e/14/f405)
<frozen _collections_abc>:836: RuntimeWarning: coroutine 'get_streaming_response' was never awaited
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-25 16:19:45.811 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 372, in <module>
    asyncio.run(get_user_input())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    await get_subject_message(prompt)
  File "/root/cs50p/project/main.py", line 188, in get_subject_message
    subject = await get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo,_async=True)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 80, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
/root/cs50p/project/main.py:50: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  await get_subject_message(prompt)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 16:21:42.275 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 406, in <module>
    for item in response:
TypeError: 'coroutine' object is not iterable
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'get_streaming_response' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:50: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  get_subject_message(prompt)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 16:24:54.941 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 420, in <module>
    asyncio.run(get_user_input())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 49, in get_user_input
    if prompt := st.chat_input(placeholder="query here"):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/chat.py", line 321, in chat_input
    widget_state = register_widget(
                   ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 161, in register_widget
    return register_widget_from_metadata(metadata, ctx, widget_func_name, element_type)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 206, in register_widget_from_metadata
    raise DuplicateWidgetID(
streamlit.errors.DuplicateWidgetID: There are multiple identical `st.chat_input` widgets with the
same generated key.

When a widget is created, it's assigned an internal key based on
its structure. Multiple widgets with an identical structure will
result in the same internal key, which causes this error.

To fix this error, please pass a unique `key` argument to
`st.chat_input`.
/root/cs50p/project/main.py:50: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  get_subject_message(prompt)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:397: RuntimeWarning: coroutine 'get_user_input' was never awaited
  # Start responding after the initial message to decrease loading time. Also do not respond to system messages.
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'run_response' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'get_user_input' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:397: RuntimeWarning: coroutine 'get_user_input' was never awaited
  # Start responding after the initial message to decrease loading time. Also do not respond to system messages.
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'run_response' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'get_user_input' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:397: RuntimeWarning: coroutine 'get_user_input' was never awaited
  # Start responding after the initial message to decrease loading time. Also do not respond to system messages.
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'run_response' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'get_user_input' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-25 16:33:06.012 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 372, in <module>
    asyncio.run(get_user_input())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 50, in get_user_input
    await get_subject_message(prompt)
  File "/root/cs50p/project/main.py", line 188, in get_subject_message
    subject = await get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo,_async=True)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 80, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
2024-01-25 19:34:18.123 Session with id 4dea2a4d-ccf4-480f-aa9b-96ffe092eba9 is already connected! Connecting to a new session.
2024-01-26 06:07:42.700 Session with id e7533805-0b81-431d-b191-1815a4f5d1bc is already connected! Connecting to a new session.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-26 10:02:25.528 Session with id 17dc5229-5621-45bc-8b81-9e19989bd7c6 is already connected! Connecting to a new session.
2024-01-26 11:35:38.455 Session with id c6bd96ee-43b4-4323-b94a-7cb8d94cfb64 is already connected! Connecting to a new session.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-26 18:23:33.844 Session with id 9d64b21b-7d10-4dd5-941b-960ea3a18eef is already connected! Connecting to a new session.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:137: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'get_subject_message' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'run_response' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:137: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-27 08:30:16.458 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 420, in <module>
    asyncio.run(get_subject_message(st.session_state.messages[-1]['role'] == 'user'))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 184, in get_subject_message
    SUBJECT_QUERY[1]["content"] += content
TypeError: can only concatenate str (not "bool") to str
2024-01-27 08:30:51.623 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 420, in <module>
    asyncio.run(get_subject_message(st.session_state.messages[-1]['role'] == 'user'))
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 184, in get_subject_message
    SUBJECT_QUERY[1]["content"] += content
TypeError: can only concatenate str (not "bool") to str
/root/cs50p/project/main.py:435: RuntimeWarning: coroutine 'main' was never awaited
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:434: RuntimeWarning: coroutine 'main' was never awaited
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-27 08:34:21.666 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 435, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 423, in main
    await asyncio.gather(get_subject_message(st.session_state.messages[-1]['role'] == 'user'),run_response())
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 184, in get_subject_message
    SUBJECT_QUERY[1]["content"] += content
TypeError: can only concatenate str (not "bool") to str
2024-01-27 08:34:22.023 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 435, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 423, in main
    await asyncio.gather(get_subject_message(st.session_state.messages[-1]['role'] == 'user'),run_response())
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 184, in get_subject_message
    SUBJECT_QUERY[1]["content"] += content
TypeError: can only concatenate str (not "bool") to str
2024-01-27 09:06:24.982 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 435, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 423, in main
    await asyncio.gather(get_subject_message(st.session_state.messages[-1]['role'] == 'user'),run_response())
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 184, in get_subject_message
    SUBJECT_QUERY[1]["content"] += content
TypeError: can only concatenate str (not "bool") to str
2024-01-27 09:06:25.162 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 435, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 423, in main
    await asyncio.gather(get_subject_message(st.session_state.messages[-1]['role'] == 'user'),run_response())
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 184, in get_subject_message
    SUBJECT_QUERY[1]["content"] += content
TypeError: can only concatenate str (not "bool") to str
/root/cs50p/project/main.py:400: RuntimeWarning: coroutine 'get_user_input' was never awaited
  
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:400: RuntimeWarning: coroutine 'get_user_input' was never awaited
  
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
2024-01-27 09:15:44.443 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 436, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 400, in main
    await asyncio.gather(get_user_input())
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    await get_subject_message(prompt),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 188, in get_subject_message
    subject = await get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo,_async=True)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 80, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:138: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-27 09:17:24.966 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 436, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 400, in main
    await asyncio.gather(get_user_input())
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    await get_subject_message(prompt),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 188, in get_subject_message
    subject = await get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo,_async=True)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 80, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
2024-01-27 09:22:16.680 Uncaught app exception
Traceback (most recent call last):
  File "/root/cs50p/project/main.py", line 64, in get_streaming_response
    response = await g4f.ChatCompletion.create_async(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/__init__.py", line 95, in create_async
    return await provider.create_async(model.name, messages, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 84, in create_async
    self.raise_exceptions()
  File "/root/cs50p/project/gpt4free/g4f/Provider/retry_provider.py", line 88, in raise_exceptions
    raise RetryProviderError("RetryProvider failed:\n" + "\n".join([
gpt4free.g4f.errors.RetryProviderError: RetryProvider failed:
GptGo: ClientResponseError: 403, message='Forbidden', url=URL('https://gptgo.ai/get_token.php')
ChatAnywhere: ClientResponseError: 522, message='', url=URL('https://chatanywhere.cn/v1/chat/gpt/')
You: RequestsError: HTTP Error 403: 
GptForLove: RuntimeUnavailableError: Could not find an available JavaScript runtime.
Chatgpt4Online: RuntimeError: No nonce found
ChatBase: ClientResponseError: 500, message='Internal Server Error', url=URL('https://www.chatbase.co/api/fe/chat')

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 439, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 403, in main
    await asyncio.gather(get_user_input())
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    await get_subject_message(prompt),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 191, in get_subject_message
    subject = await get_streaming_response(messages=SUBJECT_QUERY,model=g4f.models.gpt_35_turbo,_async=True)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 80, in get_streaming_response
    elif "UnboundLocalError" in e:
         ^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: argument of type 'RetryProviderError' is not iterable
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:65: RuntimeWarning: coroutine 'ChatCompletion.create_async' was never awaited
  model=model,
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-27 09:37:52.032 Uncaught app exception
Traceback (most recent call last):
  File "/root/cs50p/project/main.py", line 65, in get_streaming_response
    async with g4f.ChatCompletion.create_async(
TypeError: 'coroutine' object does not support the asynchronous context manager protocol

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 445, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 409, in main
    await asyncio.gather(get_user_input())
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 51, in get_user_input
    await get_subject_message(prompt),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 197, in get_subject_message
    subject = await get_streaming_response(messages=SUBJECT_QUERY,_async=True)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 86, in get_streaming_response
    elif "UnboundLocalError" in e:
         ^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: argument of type 'TypeError' is not iterable
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_url = "https://avataaars.io/?accessoriesType=Round&avatarStyle=Transparent&clotheColor=PastelYellow&clotheType=Hoodie&eyeType=Hearts&eyebrowType=SadConcernedNatural&facialHairColor=Black&facialHairType=Blank&graphicType=SkullOutline&hairColor=BrownDark&hatColor=PastelOrange&mouthType=Grimace&skinColor=Pale&topType=WinterHat4"
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_url = "https://avataaars.io/?accessoriesType=Round&avatarStyle=Transparent&clotheColor=PastelYellow&clotheType=Hoodie&eyeType=Hearts&eyebrowType=SadConcernedNatural&facialHairColor=Black&facialHairType=Blank&graphicType=SkullOutline&hairColor=BrownDark&hatColor=PastelOrange&mouthType=Grimace&skinColor=Pale&topType=WinterHat4"
2024-01-27 09:39:56.289 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 438, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 426, in main
    await asyncio.gather(run_response(), get_subject_message(st.session_state.messages[-1]['role'] == 'user'))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 187, in get_subject_message
    SUBJECT_QUERY[1]["content"] += content
TypeError: can only concatenate str (not "bool") to str
2024-01-27 09:40:28.145 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 439, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 427, in main
    await asyncio.gather(run_response(), get_subject_message(st.session_state.messages[-1]['role'] == 'user'))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 187, in get_subject_message
    SUBJECT_QUERY[1]["content"] += content
TypeError: can only concatenate str (not "bool") to str
2024-01-27 09:40:29.856 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 439, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 427, in main
    await asyncio.gather(run_response(), get_subject_message(st.session_state.messages[-1]['role'] == 'user'))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 187, in get_subject_message
    SUBJECT_QUERY[1]["content"] += content
TypeError: can only concatenate str (not "bool") to str
2024-01-27 09:41:28.716 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 439, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 436, in main
    await get_subject_message(st.session_state.messages[-1]['role'] == 'user')
  File "/root/cs50p/project/main.py", line 187, in get_subject_message
    SUBJECT_QUERY[1]["content"] += content
TypeError: can only concatenate str (not "bool") to str
/root/cs50p/project/main.py:140: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:429: RuntimeWarning: coroutine 'run_response' was never awaited
  if st.session_state["delete"]:
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-27 09:46:22.126 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 441, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 429, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
                                                             ~~~~~~~~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1153, in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1714, in _getitem_axis
    self._validate_integer(key, axis)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1647, in _validate_integer
    raise IndexError("single positional indexer is out-of-bounds")
IndexError: single positional indexer is out-of-bounds
/root/cs50p/project/main.py:429: RuntimeWarning: coroutine 'run_response' was never awaited
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-27 09:48:00.804 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 441, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 429, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0]))
                                                             ~~~~~~~~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1153, in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1714, in _getitem_axis
    self._validate_integer(key, axis)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1647, in _validate_integer
    raise IndexError("single positional indexer is out-of-bounds")
IndexError: single positional indexer is out-of-bounds
2024-01-27 09:48:24.333 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 441, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    st.write(usermessage.iloc[0][0])
             ~~~~~~~~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1153, in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1714, in _getitem_axis
    self._validate_integer(key, axis)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1647, in _validate_integer
    raise IndexError("single positional indexer is out-of-bounds")
IndexError: single positional indexer is out-of-bounds
2024-01-27 09:49:12.901 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    if usermessage:
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/generic.py", line 1519, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
/root/cs50p/project/main.py:428: FutureWarning: DataFrame.bool is now deprecated and will be removed in future version of pandas
  if usermessage:
2024-01-27 09:49:30.642 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    if usermessage.bool():
       ^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/generic.py", line 1580, in bool
    self.__nonzero__()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/generic.py", line 1519, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2024-01-27 09:49:43.137 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    if bool(usermessage):
       ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/generic.py", line 1519, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2024-01-27 09:49:59.966 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    if usermessage.iloc[0]:
       ~~~~~~~~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1153, in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1714, in _getitem_axis
    self._validate_integer(key, axis)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1647, in _validate_integer
    raise IndexError("single positional indexer is out-of-bounds")
IndexError: single positional indexer is out-of-bounds
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:430: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:431: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:431: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:431: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:428: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermessage.iloc[0]:
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:135: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:422: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 10:20:09.437 Uncaught app exception
Traceback (most recent call last):
  File "/root/cs50p/project/main.py", line 63, in get_streaming_response
    response = await g4f.ChatCompletion.create_async(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/__init__.py", line 92, in create_async
    return await provider.create_async_generator(model.name, messages, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object async_generator can't be used in 'await' expression

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 435, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 422, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 349, in run_response
    response = await get_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 72, in get_streaming_response
    response = await g4f.ChatCompletion.create_async(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/__init__.py", line 93, in create_async
    raise StreamNotSupportedError(f'{provider.__name__} does not support "stream" argument in "create_async"')
gpt4free.g4f.errors.StreamNotSupportedError: RetryProvider does not support "stream" argument in "create_async"
Task was destroyed but it is pending!
task: <Task pending name='Task-467526' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f0a2b301b70>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:428: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  chatID = st.session_state["chatID"]
/root/cs50p/project/main.py:141: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:140: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:140: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:140: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:427: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:140: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:133: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:133: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:420: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
2024-01-27 10:25:56.966 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 433, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 420, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 347, in run_response
    response = await get_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 62, in get_streaming_response
    response = await g4f.ChatCompletion.create_async(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/__init__.py", line 92, in create_async
    return await provider.create_async_generator(model.name, messages, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object async_generator can't be used in 'await' expression
Task was destroyed but it is pending!
task: <Task pending name='Task-470530' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f0a40f17870>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:134: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:421: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-27 10:26:37.368 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 434, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 421, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 348, in run_response
    response = await get_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 76, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
Task was destroyed but it is pending!
task: <Task pending name='Task-470670' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f0a2b65b130>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:140: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:427: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  chatID = st.session_state["chatID"]
/root/cs50p/project/main.py:140: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:426: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:426: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:426: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:426: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:426: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:146: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.write(
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:426: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
2024-01-27 10:48:54.914 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 440, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 410, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 276, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 25, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'query'
2024-01-27 10:49:09.815 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 440, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 410, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 276, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 25, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'query'
2024-01-27 10:49:58.418 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 440, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 410, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 276, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 25, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'query'
2024-01-27 10:50:07.245 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 440, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 410, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 276, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 25, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'query'
2024-01-27 10:52:53.006 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 440, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 410, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 276, in display_chat_history_sidebar
    subjects = conn.query(sql=sql,params=None, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 25, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'query'
2024-01-27 10:53:03.574 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 440, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 410, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 276, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 25, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'query'
2024-01-27 10:55:32.814 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 440, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 410, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 276, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 22, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'query'
2024-01-27 10:56:06.637 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 441, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 411, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 277, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'query'
2024-01-27 10:56:10.801 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 441, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 411, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 277, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'query'
2024-01-27 10:56:37.303 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 412, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 278, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 22, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: SQLConnection.query() takes 2 positional arguments but 4 were given
2024-01-27 10:57:04.671 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 412, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 278, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 22, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: SQLConnection.query() takes 2 positional arguments but 4 were given
2024-01-27 10:57:43.751 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 4, in <module>
    from db_helper import StreamlitConnection
  File "/root/cs50p/project/db_helper.py", line 20
    def query(self, sql, params**=None, ttl=None):
                               ^^^
SyntaxError: invalid syntax
2024-01-27 10:57:50.974 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 412, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 278, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 22, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: SQLConnection.query() takes 2 positional arguments but 4 were given
2024-01-27 10:57:51.370 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 412, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 278, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 22, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: SQLConnection.query() takes 2 positional arguments but 4 were given
2024-01-27 10:59:40.998 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 412, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 278, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 22, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: SQLConnection.query() takes 2 positional arguments but 4 were given
2024-01-27 11:00:44.579 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 412, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 278, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 22, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: SQLConnection.query() takes 2 positional arguments but 4 were given
2024-01-27 11:00:53.604 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 412, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 278, in display_chat_history_sidebar
    subjects = conn.query(sql, ttl=0.5)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/db_helper.py", line 22, in query
    return self.conn.query(sql, params, ttl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: SQLConnection.query() takes 2 positional arguments but 4 were given
2024-01-27 11:05:53.347 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 443, in <module>
    conn.close()
  File "/root/cs50p/project/db_helper.py", line 19, in close
    self.conn.close()
    ^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/base_connection.py", line 84, in __getattribute__
    raise e
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/base_connection.py", line 78, in __getattribute__
    return object.__getattribute__(self, name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'SQLConnection' object has no attribute 'close'
/root/cs50p/project/main.py:142: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-27 11:06:15.784 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 402, in main
    usermsg = get_user_input()
              ^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 54, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 216, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 227, in save_or_delete_message_in_sql
    with conn.session as s:
         ^^^^^^^^^^^^
AttributeError: 'StreamlitConnection' object has no attribute 'session'
/root/cs50p/project/main.py:142: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-27 11:08:29.438 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 442, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 402, in main
    usermsg = get_user_input()
              ^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 54, in get_user_input
    append_message(prompt, role='user')
  File "/root/cs50p/project/main.py", line 216, in append_message
    save_or_delete_message_in_sql(message)
  File "/root/cs50p/project/main.py", line 227, in save_or_delete_message_in_sql
    with conn.session as s:
         ^^^^^^^^^^^^
AttributeError: 'StreamlitConnection' object has no attribute 'session'
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:430: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:146: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["delete"] = True
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:430: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:430: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:139: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
2024-01-27 11:18:49.342 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 9, in <module>
    alt_client = AsyncOpenAI()
                 ^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_client.py", line 296, in __init__
    raise OpenAIError(
openai.OpenAIError: The api_key client option must be set either by passing api_key to the client or by setting the OPENAI_API_KEY environment variable
2024-01-27 11:22:47.363 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 9, in <module>
    alt_client = AsyncOpenAI()
                 ^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_client.py", line 296, in __init__
    raise OpenAIError(
openai.OpenAIError: The api_key client option must be set either by passing api_key to the client or by setting the OPENAI_API_KEY environment variable
2024-01-27 11:28:01.757 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 1, in <module>
    import gpt4free.g4f as g4f, streamlit as st, streamlit_authenticator as stauth, html, re, uuid, yaml, asyncio, dotenv, os
ModuleNotFoundError: No module named 'dotenv'
2024-01-27 11:28:40.575 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 11, in <module>
    alt_client = AsyncOpenAI(api_key=os.environ.get('OPENAI_API_KEY'))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_client.py", line 296, in __init__
    raise OpenAIError(
openai.OpenAIError: The api_key client option must be set either by passing api_key to the client or by setting the OPENAI_API_KEY environment variable
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 11:30:36.685 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 456, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 443, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 370, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
NameError: name 'get_OPENAI_streaming_response' is not defined
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 11:31:38.341 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 456, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 443, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 370, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1429, in _request
    request = self._build_request(options)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 473, in _build_request
    return self._client.build_request(  # pyright: ignore[reportUnknownMemberType]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpx/_client.py", line 359, in build_request
    return Request(
           ^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpx/_models.py", line 338, in __init__
    headers, stream = encode_request(
                      ^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpx/_content.py", line 214, in encode_request
    return encode_json(json)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpx/_content.py", line 177, in encode_json
    body = json_dumps(json).encode("utf-8")
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/__init__.py", line 231, in dumps
    return _default_encoder.encode(obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type Model is not JSON serializable
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 11:34:37.527 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 456, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 443, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 370, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: get_OPENAI_streaming_response() missing 1 required positional argument: 'model'
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 11:35:10.910 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 456, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 443, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 209, in get_subject_message
    subject = await get_OPENAI_streaming_response(messages=SUBJECT_QUERY,_async=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: get_OPENAI_streaming_response() got an unexpected keyword argument '_async'
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 11:36:05.865 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 456, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 443, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 370, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-27 11:46:43.207 Session with id 2e6d53b2-b496-4b64-8758-86df0f622321 is already connected! Connecting to a new session.
/root/cs50p/project/main.py:394: SyntaxWarning: 'ellipsis' object is not subscriptable; perhaps you missed a comma?
  if st.sidebar.button("Reset Chat"):
2024-01-27 13:23:45.218 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 458, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 394, in main
    ...     [":rainbow[Comedy]", "***Drama***", "Documentary :movie_camera:"])
    ~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: 'ellipsis' object is not subscriptable
2024-01-27 13:23:45.526 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 458, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 394, in main
    ...     [":rainbow[Comedy]", "***Drama***", "Documentary :movie_camera:"])
    ~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: 'ellipsis' object is not subscriptable
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:445: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-27 13:37:58.941 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 394, in __getitem__
    return self._getitem(widget_id, key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 439, in _getitem
    raise KeyError
KeyError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 119, in __getattr__
    return self[key]
           ~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 90, in __getitem__
    return get_session_state()[key]
           ~~~~~~~~~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/safe_session_state.py", line 89, in __getitem__
    return self._state[key]
           ~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 396, in __getitem__
    raise KeyError(_missing_key_error_message(key))
KeyError: 'st.session_state has no key "OAImessages". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 433, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 319, in display_chat_history_sidebar
    st.session_state.OAImessages.append(OAImessage)
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 121, in __getattr__
    raise AttributeError(_missing_attr_error_message(key))
AttributeError: st.session_state has no attribute "OAImessages". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization
2024-01-27 13:38:22.328 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 394, in __getitem__
    return self._getitem(widget_id, key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 439, in _getitem
    raise KeyError
KeyError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 119, in __getattr__
    return self[key]
           ~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 90, in __getitem__
    return get_session_state()[key]
           ~~~~~~~~~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/safe_session_state.py", line 89, in __getitem__
    return self._state[key]
           ~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 396, in __getitem__
    raise KeyError(_missing_key_error_message(key))
KeyError: 'st.session_state has no key "OAImessages". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 433, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 319, in display_chat_history_sidebar
    st.session_state.OAImessages.append(OAImessage)
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 121, in __getattr__
    raise AttributeError(_missing_attr_error_message(key))
AttributeError: st.session_state has no attribute "OAImessages". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:455: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:455: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:456: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  chatID = st.session_state["chatID"]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:456: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  chatID = st.session_state["chatID"]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:457: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  save_or_delete_message_in_sql(chatID=chatID,delete_all=True)
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:457: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  save_or_delete_message_in_sql(chatID=chatID,delete_all=True)
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:457: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  save_or_delete_message_in_sql(chatID=chatID,delete_all=True)
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:457: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  save_or_delete_message_in_sql(chatID=chatID,delete_all=True)
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:459: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:459: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-27 13:52:08.119 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 472, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 459, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 377, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.OAImessages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:458: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
2024-01-27 13:52:57.134 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 471, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 378, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.OAImessages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:458: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 13:57:18.430 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 471, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 378, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.OAImessages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:458: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 13:59:39.924 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 471, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 378, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.OAImessages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:458: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 14:00:57.355 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 471, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 378, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.OAImessages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:458: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 14:01:41.821 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 471, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 378, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.OAImessages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:456: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermsg:
2024-01-27 14:06:53.258 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 469, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 456, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.OAImessages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:458: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
2024-01-27 14:08:34.423 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 471, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 378, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.OAImessages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:457: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:457: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:457: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
2024-01-27 14:11:53.128 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 470, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 457, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 377, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.OAImessages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:457: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 14:12:43.024 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 470, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 457, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 377, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.OAImessages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 97, in get_OPENAI_streaming_response
    response = await alt_client.chat.completions.create(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/resources/chat/completions.py", line 1322, in create
    return await self._post(
           ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1705, in post
    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1408, in request
    return await self._request(
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/openai/_base_client.py", line 1499, in _request
    raise self._make_status_error_from_response(err.response) from None
openai.BadRequestError: Error code: 400 - {'error': {'message': "Additional properties are not allowed ('chatID', 'date', 'messageID' were unexpected) - 'messages.1'", 'type': 'invalid_request_error', 'param': None, 'code': None}}
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:448: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message_func(
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
2024-01-27 15:26:02.389 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 394, in __getitem__
    return self._getitem(widget_id, key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 439, in _getitem
    raise KeyError
KeyError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 375, in run_response
    st.write(st.session_state["OAImessages"])
             ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 90, in __getitem__
    return get_session_state()[key]
           ~~~~~~~~~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/safe_session_state.py", line 89, in __getitem__
    return self._state[key]
           ~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 396, in __getitem__
    raise KeyError(_missing_key_error_message(key))
KeyError: 'st.session_state has no key "OAImessages". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization'
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:169: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
2024-01-27 15:26:21.818 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 466, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 453, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 375, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 99, in get_OPENAI_streaming_response
    message.pop("chatID") # Remove and return the chatID key-value pair
    ^^^^^^^^^^^^^^^^^^^^^
KeyError: 'chatID'
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:170: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #delete current message, to be replaced with the edited one
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-27 15:27:08.577 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 100, in get_OPENAI_streaming_response
    message.pop("chatID") # Remove and return the chatID key-value pair
    ^^^^^^^^^^^^^^^^^^^^^
KeyError: 'chatID'
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:170: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
2024-01-27 15:29:54.891 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 466, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 453, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 379, in run_response
    for item in response:
TypeError: 'AsyncStream' object is not iterable
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
2024-01-27 15:33:02.909 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 465, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 452, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 374, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 108, in get_OPENAI_streaming_response
    return list(response)
           ^^^^^^^^^^^^^^
TypeError: 'AsyncStream' object is not iterable
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:168: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:451: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
2024-01-27 15:33:36.400 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 464, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 451, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 373, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 107, in get_OPENAI_streaming_response
    return list(response)
           ^^^^^^^^^^^^^^
TypeError: 'AsyncStream' object is not iterable
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:451: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button('edit', key=messageID):
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button('edit', key=messageID):
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button('edit', key=messageID):
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button('edit', key=messageID):
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button('edit', key=messageID):
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:103: RuntimeWarning: coroutine 'AsyncCompletions.create' was never awaited
  model=model,
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-27 15:36:55.499 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 466, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 453, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 375, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 103, in get_OPENAI_streaming_response
    async for completion in alt_client.chat.completions.create(
TypeError: 'async for' requires an object with __aiter__ method, got coroutine
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:169: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 15:40:37.513 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 466, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 453, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    full_response += item
TypeError: can only concatenate str (not "ChatCompletionChunk") to str
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:169: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214ec0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:169: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 15:42:16.881 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 466, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 453, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    full_response += item
TypeError: can only concatenate str (not "ChatCompletionChunk") to str
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:169: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 15:44:18.299 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pydantic/main.py", line 753, in __getattr__
    return pydantic_extra[item]
           ~~~~~~~~~~~~~~^^^^^^
KeyError: 'text'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 466, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 453, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 375, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 108, in get_OPENAI_streaming_response
    response.append(completion.text)
                    ^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pydantic/main.py", line 755, in __getattr__
    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
AttributeError: 'ChatCompletionChunk' object has no attribute 'text'
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320f240>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:169: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:169: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 15:47:27.077 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pydantic/main.py", line 753, in __getattr__
    return pydantic_extra[item]
           ~~~~~~~~~~~~~~^^^^^^
KeyError: 'text'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 466, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 453, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 375, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 108, in get_OPENAI_streaming_response
    response.append(completion.choices[0].delta.text)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pydantic/main.py", line 755, in __getattr__
    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
AttributeError: 'ChoiceDelta' object has no attribute 'text'
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320fa40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:169: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:169: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:451: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermsg:
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a40b43c40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["delete"] = True
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  avatar_class = "user-avatar"
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
2024-01-27 15:52:11.285 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 377, in run_response
    full_response += item
TypeError: can only concatenate str (not "tuple") to str
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320fb40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 15:52:38.129 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 15:53:24.682 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pydantic/main.py", line 753, in __getattr__
    return pydantic_extra[item]
           ~~~~~~~~~~~~~~^^^^^^
KeyError: 'choice'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 372, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 106, in get_OPENAI_streaming_response
    ): st.write(completion.choice[0])
                ^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pydantic/main.py", line 755, in __getattr__
    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
AttributeError: 'ChatCompletionChunk' object has no attribute 'choice'
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320f140>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214ec0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 15:54:11.885 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 15:54:46.835 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320f240>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a40b41540>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:17:12.031 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 377, in run_response
    full_response += item
TypeError: can only concatenate str (not "tuple") to str
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320fd40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:17:25.834 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 377, in run_response
    full_response += item
TypeError: can only concatenate str (not "tuple") to str
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320f140>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320fb40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:18:35.977 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:20:23.552 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320f940>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:21:53.961 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pydantic/main.py", line 753, in __getattr__
    return pydantic_extra[item]
           ~~~~~~~~~~~~~~^^^^^^
KeyError: 'message'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 372, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 106, in get_OPENAI_streaming_response
    ): return completion.choices[0].message.content
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pydantic/main.py", line 755, in __getattr__
    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
AttributeError: 'Choice' object has no attribute 'message'
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320fc40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:450: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:25:16.526 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 463, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 450, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    for item in response:
TypeError: 'bool' object is not iterable
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320f940>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #delete current message, to be replaced with the edited one
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:451: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-27 16:26:58.099 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 464, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 451, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 373, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 107, in get_OPENAI_streaming_response
    return completion.choices[0].delta.content
           ^^^^^^^^^^^^^^^^^^
AttributeError: 'AsyncStream' object has no attribute 'choices'
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:451: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:27:13.878 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 464, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 451, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 377, in run_response
    for item in response:
TypeError: 'AsyncStream' object is not iterable
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:451: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:27:31.325 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 464, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 451, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 377, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:168: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #delete current message, to be replaced with the edited one
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-27 16:28:44.019 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 465, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 452, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 374, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 107, in get_OPENAI_streaming_response
    for chunk in completion:
TypeError: 'AsyncStream' object is not iterable
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:159: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-27 16:32:38.485 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 466, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 453, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 375, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 109, in get_OPENAI_streaming_response
    delta = completion["choices"][0]["delta"]
            ~~~~~~~~~~^^^^^^^^^^^
TypeError: 'ChatCompletionChunk' object is not subscriptable
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a40b40540>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:168: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
2024-01-27 16:34:11.911 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 465, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 452, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 379, in run_response
    full_response += item
TypeError: can only concatenate str (not "tuple") to str
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320fa40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:168: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:34:28.582 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 465, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 452, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 378, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:168: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:35:02.918 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 465, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 452, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 378, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:168: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320fe40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a40b43e40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-27 16:45:12.780 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 466, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 453, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 379, in run_response
    for item in response:
TypeError: 'coroutine' object is not iterable
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Task was destroyed but it is pending!
task: <Task pending name='Task-557233' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214950>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py:617: RuntimeWarning: coroutine 'get_OPENAI_streaming_response' was never awaited
  gc.collect(2)
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 16:45:59.511 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 466, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 453, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    full_response += item
TypeError: can only concatenate str (not "tuple") to str
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320f240>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d32160e0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320fb40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a2ac44140>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/connection_pool.py", line 362, in __aiter__
    yield part
RuntimeError: async generator ignored GeneratorExit
Exception ignored in: <coroutine object HTTP11ConnectionByteStream.aclose at 0x7f0a0fa82c00>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 343, in aclose
    await self._connection._response_closed()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 234, in _response_closed
    async with self._state_lock:
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 69, in __aenter__
    await self._anyio_lock.acquire()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_synchronization.py", line 181, in acquire
    self.release()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_synchronization.py", line 202, in release
    if self._owner_task != get_current_task():
                           ^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_testing.py", line 59, in get_current_task
    return get_async_backend().get_current_task()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_eventloop.py", line 155, in get_async_backend
    asynclib_name = sniffio.current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a2ac44140>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/connection_pool.py", line 362, in __aiter__
    yield part
RuntimeError: async generator ignored GeneratorExit
2024-01-27 16:48:51.897 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 381, in run_response
    full_response += item
TypeError: can only concatenate str (not "tuple") to str
Exception ignored in: <coroutine object HTTP11ConnectionByteStream.aclose at 0x7f0a0f977bc0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 343, in aclose
    await self._connection._response_closed()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 234, in _response_closed
    async with self._state_lock:
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 69, in __aenter__
    await self._anyio_lock.acquire()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_synchronization.py", line 181, in acquire
    self.release()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_synchronization.py", line 202, in release
    if self._owner_task != get_current_task():
                           ^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_testing.py", line 59, in get_current_task
    return get_async_backend().get_current_task()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_eventloop.py", line 155, in get_async_backend
    asynclib_name = sniffio.current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermsg:
2024-01-27 16:49:40.695 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 465, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 452, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 378, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214b20>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button('edit', key=messageID):
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
2024-01-27 16:56:36.298 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 109, in get_OPENAI_streaming_response
    full_content += chunk.choices[0].delta.content # Append each chunk to the full content
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: can only concatenate str (not "NoneType") to str
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214b20>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a40b40940>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 19:14:26.846 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 109, in get_OPENAI_streaming_response
    full_content += chunk.choices[0].delta.content # Append each chunk to the full content
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: can only concatenate str (not "NoneType") to str
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214b20>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0dcfd740>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a40b43740>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:168: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["chatID"] = chatID
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:453: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  messageno = conn.query(sql, params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:442: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # st.write(st.session_state.messages)
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  messageno = conn.query(sql, params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  for _, message in messages.iterrows():
2024-01-27 19:26:46.402 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 456, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 443, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 369, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:444: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-27 19:27:38.275 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 444, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 370, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:162: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:444: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 19:28:02.989 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 444, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 370, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
2024-01-27 19:28:33.210 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 456, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 443, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 369, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:444: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-27 19:31:52.817 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 304, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-27 19:31:53.162 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 304, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-27 19:32:26.795 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 304, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-27 19:32:29.468 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 304, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:444: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:442: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
2024-01-27 19:40:15.244 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 455, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 442, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 366, in run_response
    response = await get_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object async_generator can't be used in 'await' expression
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:442: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 19:40:44.983 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 455, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 442, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 368, in run_response
    for item in response:
TypeError: 'async_generator' object is not iterable
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:154: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button('edit', key=messageID):
/root/cs50p/project/main.py:444: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
2024-01-27 19:43:02.134 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 444, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 370, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
2024-01-27 19:43:23.904 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 306, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
2024-01-27 19:43:26.173 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 306, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
/root/cs50p/project/main.py:156: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:444: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 19:43:52.807 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 444, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 370, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
2024-01-27 19:44:30.046 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 457, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 428, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 306, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0dcffb40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
2024-01-27 19:52:07.110 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 456, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 427, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 305, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0dcffa40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
2024-01-27 19:53:36.252 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 456, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 427, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 305, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
/root/cs50p/project/main.py:155: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:443: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 19:53:59.228 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 456, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 427, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 305, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0dcff040>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #delete current message, to be replaced with the edited one
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #delete current message, to be replaced with the edited one
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #delete current message, to be replaced with the edited one
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
2024-01-27 20:05:44.580 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 109, in get_OPENAI_streaming_response
    result = g4f.AsyncResult(content=chunk.choices[0].delta.content)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/typing.py", line 1261, in __call__
    result = self.__origin__(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: AsyncGenerator() takes no arguments
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214ec0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0dcfc240>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 20:07:22.790 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    for item in response:
  File "/root/cs50p/project/gpt4free/g4f/Provider/base_provider.py", line 149, in create_completion
    yield loop.run_until_complete(gen.__anext__())
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/Bing.py", line 503, in stream_generate
    raise Exception(f"{result['value']}: {result['message']}")
Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:170: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 20:07:40.772 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    for item in response:
  File "/root/cs50p/project/gpt4free/g4f/Provider/base_provider.py", line 149, in create_completion
    yield loop.run_until_complete(gen.__anext__())
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/gpt4free/g4f/Provider/Bing.py", line 503, in stream_generate
    raise Exception(f"{result['value']}: {result['message']}")
Exception: CaptchaChallenge: User needs to solve CAPTCHA to continue.
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermsg:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 20:09:31.981 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 381, in run_response
    full_response += item
TypeError: can only concatenate str (not "NoneType") to str
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3216f60>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 20:12:16.195 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 107, in get_OPENAI_streaming_response
    tasks = [chunk for chunk in stream] # Create a list of tasks from the stream
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: 'AsyncStream' object is not iterable
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214ec0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermsg:
2024-01-27 20:14:02.152 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 465, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 452, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 374, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object async_generator can't be used in 'await' expression
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Task was destroyed but it is pending!
task: <Task pending name='Task-595767' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214b20>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0dcfc140>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 20:15:11.806 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 465, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 452, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 378, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
Exception ignored in: <async_generator object stream_generate at 0x7f09d3215600>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:452: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 20:17:50.807 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 465, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 452, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 374, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 107, in get_OPENAI_streaming_response
    for chunk in stream:
TypeError: 'AsyncStream' object is not iterable
Exception ignored in: <async_generator object stream_generate at 0x7f09d3215600>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button('edit', key=messageID):
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0dcfdd40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
2024-01-27 20:20:14.561 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 109, in get_OPENAI_streaming_response
    content = chunk["choices"][0].get("delta", {}).get("content")
              ~~~~~^^^^^^^^^^^
TypeError: 'ChatCompletionChunk' object is not subscriptable
Exception ignored in: <async_generator object stream_generate at 0x7f09d3217870>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 20:20:41.833 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pydantic/main.py", line 753, in __getattr__
    return pydantic_extra[item]
           ~~~~~~~~~~~~~~^^^^^^
KeyError: 'get'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 376, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 109, in get_OPENAI_streaming_response
    content = chunk.choices[0].get("delta", {}).get("content")
              ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pydantic/main.py", line 755, in __getattr__
    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
AttributeError: 'Choice' object has no attribute 'get'
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0dcfdb40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3217870>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0dcffc40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-27 20:22:18.038 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d32145b0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-28 07:41:37.589 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 479, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 466, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 392, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3217300>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:163: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
2024-01-28 07:43:13.921 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 481, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 468, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 394, in run_response
    for item in response:
TypeError: 'NoneType' object is not iterable
Exception ignored in: <async_generator object stream_generate at 0x7f09d3217870>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["delete"] = True
/root/cs50p/project/main.py:458: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # for message in st.session_state.messages:
2024-01-28 07:44:51.571 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 471, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 384, in run_response
    for item in response:
TypeError: 'AsyncStream' object is not iterable
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3215600>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:458: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-28 07:49:26.989 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 471, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 114, in get_OPENAI_streaming_response
    return response.choices[0].delta.content
           ^^^^^^^^^^^^^^^^
AttributeError: 'AsyncStream' object has no attribute 'choices'
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3215090>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:458: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-28 07:51:13.646 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 471, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 113, in get_OPENAI_streaming_response
    for chunk in response:
TypeError: 'AsyncStream' object is not iterable
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214ec0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:165: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:456: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermsg:
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0dcfc840>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:165: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:165: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  with col1:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  save_or_delete_message_in_sql(chatID=chatID,delete_all=True)
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:170: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  reset()
/root/cs50p/project/main.py:461: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # Used to delete current session.
2024-01-28 08:07:10.501 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 474, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 461, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 383, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages,stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object async_generator can't be used in 'await' expression
Task was destroyed but it is pending!
task: <Task pending name='Task-607786' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214b20>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
2024-01-28 08:16:54.388 Session with id 4fd61818-726e-4419-a32f-638eb7e0df6f is already connected! Connecting to a new session.
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["delete"] = True
/root/cs50p/project/main.py:475: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:387: RuntimeWarning: coroutine 'get_OPENAI_streaming_response' was never awaited
  for item in response:
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-28 12:50:44.371 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 488, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 475, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 387, in run_response
    async for item in get_OPENAI_streaming_response(st.session_state.messages, stream=True):
TypeError: 'async for' requires an object with __aiter__ method, got coroutine
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Task was destroyed but it is pending!
task: <Task pending name='Task-609882' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f09d3215090>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:475: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-28 12:52:04.829 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 488, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 475, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 388, in run_response
    full_response += item
TypeError: can only concatenate str (not "list") to str
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3215600>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:476: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-28 12:53:01.740 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 489, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 476, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 390, in run_response
    placeholder.write(
    ^^^^^^^^^^^
UnboundLocalError: cannot access local variable 'placeholder' where it is not associated with a value
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d32160e0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:477: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  True if message["role"] == "user" else False,
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320fc40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  True if message["role"] == "user" else False,
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a40b41640>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:166: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  col1, col2 = st.columns([1,8])
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:477: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  for _, message in messages.iterrows():
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  for _, message in messages.iterrows():
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a40b40a40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  for _, message in messages.iterrows():
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320f040>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/connection_pool.py", line 362, in __aiter__
    yield part
RuntimeError: async generator ignored GeneratorExit
Exception ignored in: <coroutine object HTTP11ConnectionByteStream.aclose at 0x7f0a29ecbd80>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 343, in aclose
    await self._connection._response_closed()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 234, in _response_closed
    async with self._state_lock:
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 69, in __aenter__
    await self._anyio_lock.acquire()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_synchronization.py", line 181, in acquire
    self.release()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_synchronization.py", line 202, in release
    if self._owner_task != get_current_task():
                           ^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_testing.py", line 59, in get_current_task
    return get_async_backend().get_current_task()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/anyio/_core/_eventloop.py", line 155, in get_async_backend
    asynclib_name = sniffio.current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  for _, message in messages.iterrows():
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320f140>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
2024-01-28 13:02:38.281 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 478, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 449, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 324, in display_chat_history_sidebar
    if st.button(label=subject["subject"], key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 563, in _button
    button_proto.label = label
    ^^^^^^^^^^^^^^^^^^
TypeError: bad argument type for built-in operation
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:478: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  asyncio.run(main())
2024-01-28 13:05:45.676 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 491, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 478, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 390, in run_response
    full_response += item
                     ^^^^
UnboundLocalError: cannot access local variable 'item' where it is not associated with a value
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a0c14a940>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3216d90>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:478: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-28 13:06:06.617 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 491, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 478, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 390, in run_response
    full_response += item
TypeError: can only concatenate str (not "list") to str
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a28b9ef40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3215600>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:478: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a40b43340>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:479: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
(sqlite3.OperationalError) no such column: date_add
[SQL: SELECT * FROM messages WHERE chatID = ? AND date_add < (SELECT date_add FROM messages WHERE messageID = ?);]
[parameters: ('d281921d-8d34-4124-b659-3df81e394b58', '1d9f504d-dc07-4b41-bde9-d7e1501ddf8a')]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
Failed to check g4f pypi version: Version not found
Error connecting to the database: string index out of range
Error connecting to the database: string index out of range
Error connecting to the database: string index out of range
Error connecting to the database: string index out of range
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Error connecting to the database: (sqlite3.OperationalError) no such column: date_add
[SQL: SELECT * FROM messages WHERE chatID = ? AND date_add < (SELECT date_add FROM messages WHERE messageID = ?);]
[parameters: ('0be6d82e-801d-4e2c-aa50-3508a89ae6ff', '169133e5-29f0-4cd5-8868-b21d06f2f1f7')]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Error connecting to the database: (sqlite3.OperationalError) no such column: date_add
[SQL: SELECT * FROM messages WHERE chatID = ? AND date_add < (SELECT date_add FROM messages WHERE messageID = ?);]
[parameters: ('0be6d82e-801d-4e2c-aa50-3508a89ae6ff', '6fb28b69-34e9-48cb-bcfe-f19508c4e4ed')]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not found
Failed to check g4f pypi version: Version not foundException ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f0a28b9ef40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:478: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320fa40>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:173: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:173: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  messages = conn.query("SELECT * FROM messages WHERE chatID = :chatID ORDER BY add_date;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:173: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:173: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:173: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  messages = conn.query("SELECT * FROM messages WHERE chatID = :chatID ORDER BY add_date;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:173: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:173: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:173: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  messages = conn.query("SELECT * FROM messages WHERE chatID = :chatID ORDER BY add_date;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:173: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #edit button should not be used on the first message
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # st.write(st.session_state.messages)
2024-01-28 13:28:35.683 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 479, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 466, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 388, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages, stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object async_generator can't be used in 'await' expression
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Task was destroyed but it is pending!
task: <Task pending name='Task-619639' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214cf0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # Used to delete current session.
2024-01-28 13:29:55.307 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 482, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 469, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 392, in run_response
    full_response += item
TypeError: can only concatenate str (not "list") to str
Exception ignored in: <async_generator object HTTP11ConnectionByteStream.__aiter__ at 0x7f09d320f140>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_async/http11.py", line 335, in __aiter__
    with AsyncShieldCancellation():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 175, in __init__
    self._backend = current_async_library()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/httpcore/_synchronization.py", line 29, in current_async_library
    environment = sniffio.current_async_library()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sniffio/_impl.py", line 93, in current_async_library
    raise AsyncLibraryNotFoundError(
sniffio._impl.AsyncLibraryNotFoundError: unknown async library, or not in async context
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
Exception ignored in: <async_generator object stream_generate at 0x7f09d3214780>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:478: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:478: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-28 13:34:42.186 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 491, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 478, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 389, in run_response
    response = await get_OPENAI_streaming_response(st.session_state.messages, stream=True)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object async_generator can't be used in 'await' expression
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
Task was destroyed but it is pending!
task: <Task pending name='Task-622368' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f09d32160e0>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:470: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message,
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:470: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message,
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:470: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message,
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:470: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message,
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message_func(
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # Set a custom (system) instruction for the LLM.
/root/cs50p/project/main.py:380: RuntimeWarning: coroutine 'get_streaming_response' was never awaited
  # Start responding after the initial message to decrease loading time. Also do not respond to system messages.
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-28 13:40:37.274 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    async for item in response_generator(st.session_state.messages, stream=True):
TypeError: 'async for' requires an object with __aiter__ method, got coroutine
Task was destroyed but it is pending!
task: <Task pending name='Task-626729' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f09d3215090>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:380: RuntimeWarning: coroutine 'get_streaming_response' was never awaited
  async for item in response_generator(st.session_state.messages, stream=True):
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
2024-01-28 13:41:14.245 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    async for item in response_generator(st.session_state.messages, stream=True):
TypeError: 'async for' requires an object with __aiter__ method, got coroutine
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:454: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
2024-01-28 13:42:17.026 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 467, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 454, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 380, in run_response
    async for item in await response_generator(st.session_state.messages, stream=True):
TypeError: 'async for' requires an object with __aiter__ method, got generator
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:510: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:510: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:510: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:510: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:507: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:507: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:507: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:507: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:507: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:504: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:504: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:465: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:477: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
2024-01-28 14:20:21.040 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 490, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 477, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 219, in get_subject_message
    with await st.spinner("Getting subject"):
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: object _GeneratorContextManager can't be used in 'await' expression
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:477: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:160: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if is_user:
/root/cs50p/project/main.py:470: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  True if message["role"] == "user" else False,
2024-01-28 14:22:16.685 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 483, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 470, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 389, in run_response
    for item in response_items:
TypeError: 'NoneType' object is not iterable
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
Task was destroyed but it is pending!
task: <Task pending name='Task-649826' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f09d3216d90>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:161: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #the edit button is pressed to edit a message. All chat history below the response will be deleted.
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
2024-01-28 14:23:14.040 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 484, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 269, in __step
    result = coro.throw(exc)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 471, in main
    await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 339, in __wakeup
    future.result()
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 389, in run_response
    response_items = await get_streaming_response(st.session_state.messages, stream=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 80, in get_streaming_response
    if response:
       ^^^^^^^^
UnboundLocalError: cannot access local variable 'response' where it is not associated with a value
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
Task was destroyed but it is pending!
task: <Task pending name='Task-650199' coro=<TCPConnector._resolve_host() running at /root/anaconda3/envs/cs50/lib/python3.11/site-packages/aiohttp/connector.py:884> wait_for=<Future pending cb=[_chain_future.<locals>._call_check_cancel() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py:387, Task.__wakeup()]> cb=[shield.<locals>._inner_done_callback() at /root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py:881]>
Exception ignored in: <async_generator object stream_generate at 0x7f09d3216650>
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 617, in _on_script_finished
    gc.collect(2)
RuntimeError: async generator ignored GeneratorExit
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:477: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  chatID = st.session_state["chatID"]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  message = conn.query("SELECT subject FROM subject WHERE chatID = :chatID;", params={"chatID":chatID},ttl=0.5)
2024-01-28 14:52:41.997 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 491, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 455, in main
    if instruction := st.sidebar.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=systemmsg.iloc[0][0],placeholder='Custom instruction for LLM',label_visibility='collapsed'):
                                                                                                                          ~~~~~~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1153, in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1714, in _getitem_axis
    self._validate_integer(key, axis)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1647, in _validate_integer
    raise IndexError("single positional indexer is out-of-bounds")
IndexError: single positional indexer is out-of-bounds
2024-01-28 14:54:41.387 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 495, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 455, in main
    if systemmsg.iloc[0][0] is None:
       ~~~~~~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1153, in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1714, in _getitem_axis
    self._validate_integer(key, axis)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1647, in _validate_integer
    raise IndexError("single positional indexer is out-of-bounds")
IndexError: single positional indexer is out-of-bounds
2024-01-28 14:54:55.445 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 495, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    systemmsg.iloc[0][0]
    ~~~~~~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1153, in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1714, in _getitem_axis
    self._validate_integer(key, axis)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1647, in _validate_integer
    raise IndexError("single positional indexer is out-of-bounds")
IndexError: single positional indexer is out-of-bounds
2024-01-28 14:55:30.639 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 495, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 455, in main
    if systemmsg.iloc[0] is None:
       ~~~~~~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1153, in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1714, in _getitem_axis
    self._validate_integer(key, axis)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1647, in _validate_integer
    raise IndexError("single positional indexer is out-of-bounds")
IndexError: single positional indexer is out-of-bounds
2024-01-28 14:55:46.641 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 496, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 459, in main
    systemmsg.iloc[0][0]
    ~~~~~~~~~~~~~~^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1153, in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1714, in _getitem_axis
    self._validate_integer(key, axis)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/indexing.py", line 1647, in _validate_integer
    raise IndexError("single positional indexer is out-of-bounds")
IndexError: single positional indexer is out-of-bounds
2024-01-28 14:56:19.511 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 497, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 461, in main
    if instruction := st.sidebar.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
                                                                                                                          ^^^^^
NameError: name 'value' is not defined
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:484: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:456: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # if systemmsg is None:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:482: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermsg:
/root/cs50p/project/main.py:456: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # if systemmsg is None:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:456: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # if systemmsg is None:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:460: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # value = ''
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:460: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # value = ''
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:460: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # value = ''
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:460: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # value = ''
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:460: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # value = ''
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:460: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # value = ''
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:460: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # value = ''
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:460: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # value = ''
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:460: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  # value = ''
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:459: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #     systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:459: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  #     systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-28 15:08:54.033 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 495, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 462, in main
    if instruction := st.text(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: TextMixin.text() got an unexpected keyword argument 'label'
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:487: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:487: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:487: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if not st.session_state["instructionactive"]:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-28 15:22:26.791 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 500, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 462, in main
    if not value:
           ^^^^^
UnboundLocalError: cannot access local variable 'value' where it is not associated with a value
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  except:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  except:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  except:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:485: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermsg:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:485: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermsg:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:486: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:486: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:174: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.session_state["subject"] = message.iloc[0][0]
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:486: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  try:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-28 15:31:19.171 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 499, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 424, in main
    model = st.sidebar.radio("LLM",options=[":green[GPT4Free]",":blue[OPENAI]"],horizontal=True,label_visibility=False)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/radio.py", line 215, in radio
    return self._radio(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/radio.py", line 253, in _radio
    maybe_raise_label_warnings(label, label_visibility)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/type_util.py", line 1045, in maybe_raise_label_warnings
    raise errors.StreamlitAPIException(
streamlit.errors.StreamlitAPIException: Unsupported label_visibility option 'False'. Valid values are 'visible', 'hidden' or 'collapsed'.
2024-01-28 15:31:19.524 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 499, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 424, in main
    model = st.sidebar.radio("LLM",options=[":green[GPT4Free]",":blue[OPENAI]"],horizontal=True,label_visibility=False)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/radio.py", line 215, in radio
    return self._radio(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/radio.py", line 253, in _radio
    maybe_raise_label_warnings(label, label_visibility)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/type_util.py", line 1045, in maybe_raise_label_warnings
    raise errors.StreamlitAPIException(
streamlit.errors.StreamlitAPIException: Unsupported label_visibility option 'False'. Valid values are 'visible', 'hidden' or 'collapsed'.
2024-01-28 15:31:37.221 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 499, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 424, in main
    model = st.sidebar.radio("LLM",options=[":green[GPT4Free]",":blue[OPENAI]"],horizontal=True,label_visibility=False)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/radio.py", line 215, in radio
    return self._radio(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/radio.py", line 253, in _radio
    maybe_raise_label_warnings(label, label_visibility)
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/type_util.py", line 1045, in maybe_raise_label_warnings
    raise errors.StreamlitAPIException(
streamlit.errors.StreamlitAPIException: Unsupported label_visibility option 'False'. Valid values are 'visible', 'hidden' or 'collapsed'.
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:464: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-28 15:36:22.237 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 502, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 463, in main
    if c_instruction:
       ^^^^^^^^^^^^^
UnboundLocalError: cannot access local variable 'c_instruction' where it is not associated with a value
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-28 15:39:43.358 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 394, in __getitem__
    return self._getitem(widget_id, key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 439, in _getitem
    raise KeyError
KeyError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 500, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 461, in main
    if st.session_state["instruction"]:
       ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 90, in __getitem__
    return get_session_state()[key]
           ~~~~~~~~~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/safe_session_state.py", line 89, in __getitem__
    return self._state[key]
           ~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 396, in __getitem__
    raise KeyError(_missing_key_error_message(key))
KeyError: 'st.session_state has no key "instruction". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization'
2024-01-28 15:39:48.663 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 394, in __getitem__
    return self._getitem(widget_id, key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 439, in _getitem
    raise KeyError
KeyError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 500, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 461, in main
    if st.session_state["instruction"]:
       ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 90, in __getitem__
    return get_session_state()[key]
           ~~~~~~~~~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/safe_session_state.py", line 89, in __getitem__
    return self._state[key]
           ~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 396, in __getitem__
    raise KeyError(_missing_key_error_message(key))
KeyError: 'st.session_state has no key "instruction". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization'
2024-01-28 15:40:19.657 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 394, in __getitem__
    return self._getitem(widget_id, key)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 439, in _getitem
    raise KeyError
KeyError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 501, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 462, in main
    if st.session_state["instruction"]:
       ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state_proxy.py", line 90, in __getitem__
    return get_session_state()[key]
           ~~~~~~~~~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/safe_session_state.py", line 89, in __getitem__
    return self._state[key]
           ~~~~~~~~~~~^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/session_state.py", line 396, in __getitem__
    raise KeyError(_missing_key_error_message(key))
KeyError: 'st.session_state has no key "instruction". Did you forget to initialize it? More info: https://docs.streamlit.io/library/advanced-features/session-state#initialization'
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if instruction := st.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if instruction := st.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if instruction := st.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if instruction := st.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if instruction := st.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if instruction := st.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if instruction := st.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if instruction := st.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if instruction := st.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:469: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if instruction := st.text_area(label='Custom instruction for LLM',key=st.session_state["instructionID"],value=value,placeholder='Custom instruction for LLM',label_visibility='collapsed'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:470: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if value != instruction:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:470: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if value != instruction:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:470: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if value != instruction:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:470: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if value != instruction:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:468: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = ""
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:487: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:466: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  value = systemmsg.iloc[0][0]
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:493: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:493: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:493: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:471: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  append_message(instruction, role='system')
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:493: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if st.button(label='❌'):
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-28 16:22:12.761 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 509, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 429, in main
    col1.login()
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/delta_generator.py", line 352, in wrapper
    raise StreamlitAPIException(message)
streamlit.errors.StreamlitAPIException: `login()` is not a valid Streamlit command.
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:472: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  systemmsg = conn.query("SELECT content FROM messages WHERE chatID = :chatID and role = 'system' ORDER BY add_date DESC LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:494: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if usermsg:
/root/cs50p/project/main.py:472: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  systemmsg = conn.query("SELECT content FROM messages WHERE chatID = :chatID and role = 'system' ORDER BY add_date DESC LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:472: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  systemmsg = conn.query("SELECT content FROM messages WHERE chatID = :chatID and role = 'system' ORDER BY add_date DESC LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:494: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:494: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:495: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  st.rerun()
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-29 07:07:23.461 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 264, in _get_or_create_cached_value
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 312, in _handle_cache_miss
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: no such column: m.message

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 526, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    search_history(text_search)
  File "/root/cs50p/project/main.py", line 320, in search_history
    results = conn.query(sql, params={"searchtext":searchtext}, ttl=0.5)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 238, in query
    return _query(
           ^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 212, in wrapper
    return cached_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 241, in __call__
    return self._get_or_create_cached_value(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 267, in _get_or_create_cached_value
    return self._handle_cache_miss(cache, value_key, func_args, func_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 321, in _handle_cache_miss
    computed_value = self._info.func(*func_args, **func_kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 289, in wrapped_f
    return self(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 379, in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 325, in iter
    raise retry_exc.reraise()
          ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 158, in reraise
    raise self.last_attempt.result()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 382, in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 216, in _query
    return pd.read_sql(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 682, in read_sql
    return pandas_sql.read_query(
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1776, in read_query
    result = self.execute(sql, params)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1600, in execute
    return self.con.execute(sql, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1380, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such column: m.message
[SQL: 
            SELECT DISTINCT s.subject
            FROM subject s 
            JOIN messages m ON s.chatID = m.chatID
            WHERE s.subject IS NOT NULL
            AND m.message LIKE '%?%'
            ORDER BY m.add_date DESC
            LIMIT 25;
            ]
[parameters: ('session',)]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-29 07:07:26.057 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 264, in _get_or_create_cached_value
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 312, in _handle_cache_miss
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: no such column: m.message

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 526, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    search_history(text_search)
  File "/root/cs50p/project/main.py", line 320, in search_history
    results = conn.query(sql, params={"searchtext":searchtext}, ttl=0.5)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 238, in query
    return _query(
           ^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 212, in wrapper
    return cached_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 241, in __call__
    return self._get_or_create_cached_value(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 267, in _get_or_create_cached_value
    return self._handle_cache_miss(cache, value_key, func_args, func_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 321, in _handle_cache_miss
    computed_value = self._info.func(*func_args, **func_kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 289, in wrapped_f
    return self(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 379, in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 325, in iter
    raise retry_exc.reraise()
          ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 158, in reraise
    raise self.last_attempt.result()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 382, in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 216, in _query
    return pd.read_sql(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 682, in read_sql
    return pandas_sql.read_query(
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1776, in read_query
    result = self.execute(sql, params)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1600, in execute
    return self.con.execute(sql, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1380, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such column: m.message
[SQL: 
            SELECT DISTINCT s.subject
            FROM subject s 
            JOIN messages m ON s.chatID = m.chatID
            WHERE s.subject IS NOT NULL
            AND m.message LIKE '%?%'
            ORDER BY m.add_date DESC
            LIMIT 25;
            ]
[parameters: ('session',)]
(Background on this error at: https://sqlalche.me/e/14/e3q8)
2024-01-29 07:07:53.533 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 264, in _get_or_create_cached_value
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 312, in _handle_cache_miss
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 0, and there are 1 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 526, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    search_history(text_search)
  File "/root/cs50p/project/main.py", line 320, in search_history
    results = conn.query(sql, params={"searchtext":searchtext}, ttl=0.5)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 238, in query
    return _query(
           ^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 212, in wrapper
    return cached_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 241, in __call__
    return self._get_or_create_cached_value(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 267, in _get_or_create_cached_value
    return self._handle_cache_miss(cache, value_key, func_args, func_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 321, in _handle_cache_miss
    computed_value = self._info.func(*func_args, **func_kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 289, in wrapped_f
    return self(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 379, in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 325, in iter
    raise retry_exc.reraise()
          ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 158, in reraise
    raise self.last_attempt.result()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 382, in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 216, in _query
    return pd.read_sql(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 682, in read_sql
    return pandas_sql.read_query(
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1776, in read_query
    result = self.execute(sql, params)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1600, in execute
    return self.con.execute(sql, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1380, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 0, and there are 1 supplied.
[SQL: 
            SELECT DISTINCT s.subject
            FROM subject s 
            JOIN messages m ON s.chatID = m.chatID
            WHERE s.subject IS NOT NULL
            AND m.content LIKE '%?%'
            ORDER BY m.add_date DESC
            LIMIT 25;
            ]
[parameters: ('session',)]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-29 07:08:32.542 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 264, in _get_or_create_cached_value
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 87, in get
    entry_bytes = self._read_from_mem_cache(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 137, in _read_from_mem_cache
    raise CacheStorageKeyNotFoundError("Key not found in mem cache")
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Key not found in mem cache

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 634, in read_result
    pickled_entry = self.storage.get(key)
                    ^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/in_memory_cache_storage_wrapper.py", line 89, in get
    entry_bytes = self._persist_storage.get(key)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/storage/local_disk_cache_storage.py", line 155, in get
    raise CacheStorageKeyNotFoundError(
streamlit.runtime.caching.storage.cache_storage_protocol.CacheStorageKeyNotFoundError: Local disk cache storage is disabled (persist=None)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 312, in _handle_cache_miss
    cached_result = cache.read_result(value_key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_data_api.py", line 636, in read_result
    raise CacheKeyNotFoundError(str(e)) from e
streamlit.runtime.caching.cache_errors.CacheKeyNotFoundError: Local disk cache storage is disabled (persist=None)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlite3.ProgrammingError: Incorrect number of bindings supplied. The current statement uses 0, and there are 1 supplied.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 526, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 458, in main
    search_history(text_search)
  File "/root/cs50p/project/main.py", line 320, in search_history
    results = conn.query(sql, params={"searchtext":searchtext}, ttl=0.5)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 238, in query
    return _query(
           ^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 212, in wrapper
    return cached_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 241, in __call__
    return self._get_or_create_cached_value(args, kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 267, in _get_or_create_cached_value
    return self._handle_cache_miss(cache, value_key, func_args, func_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/caching/cache_utils.py", line 321, in _handle_cache_miss
    computed_value = self._info.func(*func_args, **func_kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 289, in wrapped_f
    return self(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 379, in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 325, in iter
    raise retry_exc.reraise()
          ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 158, in reraise
    raise self.last_attempt.result()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/tenacity/__init__.py", line 382, in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/connections/sql_connection.py", line 216, in _query
    return pd.read_sql(
           ^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 682, in read_sql
    return pandas_sql.read_query(
           ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1776, in read_query
    result = self.execute(sql, params)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/io/sql.py", line 1600, in execute
    return self.con.execute(sql, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1380, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 334, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1572, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1943, in _execute_context
    self._handle_dbapi_exception(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2124, in _handle_dbapi_exception
    util.raise_(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 211, in raise_
    raise exception
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1900, in _execute_context
    self.dialect.do_execute(
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 736, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Incorrect number of bindings supplied. The current statement uses 0, and there are 1 supplied.
[SQL: 
            SELECT DISTINCT s.subject
            FROM subject s 
            JOIN messages m ON s.chatID = m.chatID
            WHERE s.subject IS NOT NULL
            AND m.content LIKE '% ? %'
            ORDER BY m.add_date DESC
            LIMIT 25;
            ]
[parameters: ('session',)]
(Background on this error at: https://sqlalche.me/e/14/f405)
2024-01-29 07:10:24.769 Session with id b0826a72-8940-45a0-b86e-df710d69763a is already connected! Connecting to a new session.
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:513: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:513: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:513: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:513: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:513: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:513: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:513: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:513: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  await asyncio.gather(run_response(), get_subject_message(usermessage.iloc[0][0]))
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
2024-01-29 18:19:43.170 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 323, in <module>
    def display_chat_history_sidebar(input: g4f.dataframe = None) -> None:
                                            ^^^^^^^^^^^^^
AttributeError: module 'gpt4free.g4f' has no attribute 'dataframe'
2024-01-29 18:22:55.441 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 527, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 459, in main
    search_history(text_search)
  File "/root/cs50p/project/main.py", line 321, in search_history
    display_chat_history_sidebar(results)
  File "/root/cs50p/project/main.py", line 336, in display_chat_history_sidebar
    if input:
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/generic.py", line 1519, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2024-01-29 18:22:55.827 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 527, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 459, in main
    search_history(text_search)
  File "/root/cs50p/project/main.py", line 321, in search_history
    display_chat_history_sidebar(results)
  File "/root/cs50p/project/main.py", line 336, in display_chat_history_sidebar
    if input:
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/pandas/core/generic.py", line 1519, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2024-01-29 18:23:32.292 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 324, in <module>
    def display_chat_history_sidebar(input: st.DataFrame = None) -> None:
                                            ^^^^^^^^^^^^
AttributeError: module 'streamlit' has no attribute 'DataFrame'
2024-01-29 18:23:49.100 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 527, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 485, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 353, in display_chat_history_sidebar
    if st.button(label=display_subject(subject["subject"]), key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 576, in _button
    button_state = register_widget(
                   ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 161, in register_widget
    return register_widget_from_metadata(metadata, ctx, widget_func_name, element_type)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 194, in register_widget_from_metadata
    raise DuplicateWidgetID(
streamlit.errors.DuplicateWidgetID: There are multiple widgets with the same `key='83d776b0-bd9d-4ee0-a909-ef5fde9eabf4'`.

To fix this, please make sure that the `key` argument is unique for each
widget you create.
2024-01-29 18:23:57.643 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 527, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 485, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 353, in display_chat_history_sidebar
    if st.button(label=display_subject(subject["subject"]), key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 576, in _button
    button_state = register_widget(
                   ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 161, in register_widget
    return register_widget_from_metadata(metadata, ctx, widget_func_name, element_type)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 194, in register_widget_from_metadata
    raise DuplicateWidgetID(
streamlit.errors.DuplicateWidgetID: There are multiple widgets with the same `key='83d776b0-bd9d-4ee0-a909-ef5fde9eabf4'`.

To fix this, please make sure that the `key` argument is unique for each
widget you create.
2024-01-29 18:26:31.434 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 528, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 486, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 354, in display_chat_history_sidebar
    if st.button(label=display_subject(subject["subject"]), key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 576, in _button
    button_state = register_widget(
                   ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 161, in register_widget
    return register_widget_from_metadata(metadata, ctx, widget_func_name, element_type)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 194, in register_widget_from_metadata
    raise DuplicateWidgetID(
streamlit.errors.DuplicateWidgetID: There are multiple widgets with the same `key='83d776b0-bd9d-4ee0-a909-ef5fde9eabf4'`.

To fix this, please make sure that the `key` argument is unique for each
widget you create.
2024-01-29 18:29:15.802 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 528, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 486, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 354, in display_chat_history_sidebar
    if st.button(label=display_subject(subject["subject"]), key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 576, in _button
    button_state = register_widget(
                   ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 161, in register_widget
    return register_widget_from_metadata(metadata, ctx, widget_func_name, element_type)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 194, in register_widget_from_metadata
    raise DuplicateWidgetID(
streamlit.errors.DuplicateWidgetID: There are multiple widgets with the same `key='83d776b0-bd9d-4ee0-a909-ef5fde9eabf4'`.

To fix this, please make sure that the `key` argument is unique for each
widget you create.
2024-01-29 18:29:27.884 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 528, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 486, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 354, in display_chat_history_sidebar
    if st.button(label=display_subject(subject["subject"]), key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 576, in _button
    button_state = register_widget(
                   ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 161, in register_widget
    return register_widget_from_metadata(metadata, ctx, widget_func_name, element_type)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 194, in register_widget_from_metadata
    raise DuplicateWidgetID(
streamlit.errors.DuplicateWidgetID: There are multiple widgets with the same `key='83d776b0-bd9d-4ee0-a909-ef5fde9eabf4'`.

To fix this, please make sure that the `key` argument is unique for each
widget you create.
2024-01-29 18:30:16.392 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 528, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 486, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 354, in display_chat_history_sidebar
    if st.button(label=display_subject(subject["subject"]), key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 576, in _button
    button_state = register_widget(
                   ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 161, in register_widget
    return register_widget_from_metadata(metadata, ctx, widget_func_name, element_type)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 194, in register_widget_from_metadata
    raise DuplicateWidgetID(
streamlit.errors.DuplicateWidgetID: There are multiple widgets with the same `key='83d776b0-bd9d-4ee0-a909-ef5fde9eabf4'`.

To fix this, please make sure that the `key` argument is unique for each
widget you create.
2024-01-29 18:31:20.007 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 528, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 486, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 340, in display_chat_history_sidebar
    for _, subject in subjects.iterrows():
                      ^^^^^^^^
UnboundLocalError: cannot access local variable 'subjects' where it is not associated with a value
2024-01-29 18:31:48.481 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 527, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 485, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 340, in display_chat_history_sidebar
    for _, subject in subjects.iterrows():
                      ^^^^^^^^
UnboundLocalError: cannot access local variable 'subjects' where it is not associated with a value
2024-01-29 18:32:37.084 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 528, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 486, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 341, in display_chat_history_sidebar
    for _, subject in subjects.iterrows():
                      ^^^^^^^^
UnboundLocalError: cannot access local variable 'subjects' where it is not associated with a value
2024-01-29 18:33:11.862 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 527, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 485, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 353, in display_chat_history_sidebar
    if st.button(label=display_subject(subject["subject"]), key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 576, in _button
    button_state = register_widget(
                   ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 161, in register_widget
    return register_widget_from_metadata(metadata, ctx, widget_func_name, element_type)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 194, in register_widget_from_metadata
    raise DuplicateWidgetID(
streamlit.errors.DuplicateWidgetID: There are multiple widgets with the same `key='83d776b0-bd9d-4ee0-a909-ef5fde9eabf4'`.

To fix this, please make sure that the `key` argument is unique for each
widget you create.
2024-01-29 18:33:26.104 Uncaught app exception
Traceback (most recent call last):
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 534, in _run_script
    exec(code, module.__dict__)
  File "/root/cs50p/project/main.py", line 528, in <module>
    asyncio.run(main())
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 31, in run
    return loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/.local/lib/python3.11/site-packages/nest_asyncio.py", line 99, in run_until_complete
    return f.result()
           ^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/futures.py", line 203, in result
    raise self._exception.with_traceback(self._exception_tb)
  File "/root/anaconda3/envs/cs50/lib/python3.11/asyncio/tasks.py", line 267, in __step
    result = coro.send(None)
             ^^^^^^^^^^^^^^^
  File "/root/cs50p/project/main.py", line 486, in main
    display_chat_history_sidebar()
  File "/root/cs50p/project/main.py", line 354, in display_chat_history_sidebar
    if st.button(label=display_subject(subject["subject"]), key=chatID, use_container_width=True):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/metrics_util.py", line 396, in wrapped_func
    result = non_optional_func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 157, in button
    return self.dg._button(
           ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/elements/widgets/button.py", line 576, in _button
    button_state = register_widget(
                   ^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 161, in register_widget
    return register_widget_from_metadata(metadata, ctx, widget_func_name, element_type)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/root/anaconda3/envs/cs50/lib/python3.11/site-packages/streamlit/runtime/state/widgets.py", line 194, in register_widget_from_metadata
    raise DuplicateWidgetID(
streamlit.errors.DuplicateWidgetID: There are multiple widgets with the same `key='83d776b0-bd9d-4ee0-a909-ef5fde9eabf4'`.

To fix this, please make sure that the `key` argument is unique for each
widget you create.
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:514: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  usermessage = conn.query("SELECT content FROM messages WHERE chatID = :chatID AND role = 'user' ORDER BY add_date LIMIT 1;",params={"chatID":st.session_state["chatID"]},ttl=0.5)
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:509: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  True if message["role"] == "assistant" else False,
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:509: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  True if message["role"] == "assistant" else False,
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:545: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:565: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
/root/cs50p/project/main.py:203: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  </div>
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:509: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  True if message["role"] == "assistant" else False,
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
/root/cs50p/project/main.py:167: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  if messageno.iloc[0][0] != messageID:
